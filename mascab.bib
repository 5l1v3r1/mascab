% =============================================================================
@STRING{KEYWORDS={class=misc/history}}

@inproceedings{MASCAB:BerLanSch:12,
  keywords     = KEYWORDS,
  author       = {D.J. Bernstein and T. Lange and P. Schwabe},
  title        = {The Security Impact of a New Cryptographic Library},
  booktitle    = {Progress in Cryptology (LATINCRYPT)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 7533},
  pages        = {159--176},
  year         = {2012},
  addendum     = {
    See Section $3$ for a detailed description of by-design security against
    micro-architectural attack in the NaCl library.
  }
} 

@inproceedings{MASCAB:Bernstein:08,
  keywords     = KEYWORDS,
  author       = {D.J. Bernstein},
  title        = {The {Salsa20} family of stream ciphers},
  booktitle    = {New Stream Cipher Designs: The eSTREAM Finalists}, 
  publisher    = {Springer-Verlag},
  series       = {LNCS 4986}, 
  pages        = {84--97}, 
  year         = {2008},
  addendum     = {
    Section $2.3$ of this paper presents an argument for security-by-design,
    wrt. use of look-up tables for S-boxes and more generally, noting for
    example that
    ``{\em [a] further argument against S-box lookups is that, on most platforms, they are vulnerable to timing attacks}''.
  }
}

@article{MASCAB:KSWH:00,
  keywords     = KEYWORDS,
  author       = {J. Kelsey and B. Schneier and D. Wagner and C. Hall},
  title        = {Side Channel Cryptanalysis of Product Ciphers},
  journal      = {Journal of Computer Security}, 
  volume       = {8},
  number       = {2-3}, 
  pages        = {141--158}, 
  year         = {2000},
  addendum     = {
    This paper starts to make more confident predictions about the threat of
    micro-architectural attacks, stating that
    ``{\em [w]e believe attacks based on cache hit ratio in large S-box ciphers like Blowfish, CAST, and Khufu are possible}''.
  }
}

@inproceedings{MASCAB:SchWhi:98,
  keywords     = KEYWORDS,
  author       = {B. Schneier and D. Whiting},
  title        = {{Twofish} on Smart Cards},
  booktitle    = {Smart Card Research and Applications (CARDIS)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 1820}, 
  pages        = {265--276}, 
  year         = {1998},
  addendum     = {
    This paper is evidence that attention to micro-architectural attacks can
    be identified quite early within the history of academic publications on 
    side-channel attacks more generally.  
    Two quotes in Section $4.6$ stand out, for example:
    1) ``{\em [t]iming attacks based on cache hits are not applicable to smart cards as they typically do not have a cache}''
       and
    2) ``{\em [o]n some CPUs the multiply instruction uses an ``early out'' algorithm}''.
    Clearly the former is reasonable based on the date of publication, even
    if invalidated wrt. modern examples; the latter acts as a prediction of
    sorts, later realised in concrete attacks using exactly this behaviour.
  }
}

@inproceedings{MASCAB:Kocher:96,
  keywords     = KEYWORDS,
  author       = {P.C. Kocher},
  title        = {Timing Attacks on Implementations of {Diffie-Hellman}, {RSA}, {DSS}, and Other Systems},
  booktitle    = {Advances in Cryptology (CRYPTO)},
  publisher    = {Springer-Verlag LNCS 1109}, 
  pages        = {104--113}, 
  year         = {1996},
  addendum     = {
    This paper is evidence that attention to micro-architectural attacks can
    be identified quite early within the history of academic publications on 
    side-channel attacks more generally.
    The point is made in various places, but in Section $11$ for example the
    paper states that
    ``{\em RAM cache hits can produce timing characteristics in implementations of Blowfish, SEAL, DES, and other ciphers if tables in memory are not used identically in every encryption}''
    thus clearly predicting later, concrete attacks.
  }
}

@article{MASCAB:Lampson:73,
  keywords     = KEYWORDS,
  author       = {B.W. Lampson},
  title        = {A note on the confinement problem},
  journal      = {Communications of the ACM (CACM)},
  volume       = {16},
  number       = {10},
  pages        = {613--615},
  year         = {1973},
  addendum     = {
    This is a seminal paper, exploring various foundational topics: in the
    abstract, it
    1) defines the confinement problem, namely the problem of preventing a
       process communicating with some other process during execution,
    2) defines some terminology, namely
       a covert  channel as ``those not intended for information transfer at all, such as the service program's effect on the system load'',
       and
       a storage channel as ``[s]torage of various kinds maintained by the supervisor which can be written by the service and read by an unconfined program, either shortly after it is written or at some later time'',
    3) defines various necessary conditions for confinement, concluding
       ``[t]here is not likely to be any rigorous way of identifying every channel in any system of even moderate complexity''
       st. sufficient conditions are hard to provide in a generic manner.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/datasheet}}

@techreport{MASCAB:intel_sdm_v1:17,
  keywords     = KEYWORDS,
  author       = {Intel},
  title        = {{Intel} 64 and {IA-32} architectures software developer's manual volume 1:                            Basic architecture},
  number       = {253665},
  year         = {2017},
  url          = {http://software.intel.com/en-us/articles/intel-sdm}
}
  
@techreport{MASCAB:intel_sdm_v2:17,
  keywords     = KEYWORDS,
  author       = {Intel},
  title        = {{Intel} 64 and {IA-32} architectures software developer's manual combined volumes 2A, 2B, 2C, and 2D: Instruction set reference, {A-Z}},
  number       = {325383},
  year         = {2017},
  url          = {http://software.intel.com/en-us/articles/intel-sdm}
}

@techreport{MASCAB:intel_sdm_v3:17,
  keywords     = KEYWORDS,
  author       = {Intel},
  title        = {{Intel} 64 and {IA-32} architectures software developer's manual combined volumes 3A, 3B, 3C, and 3D: System programming guide},
  number       = {325384},
  year         = {2017},
  url          = {http://software.intel.com/en-us/articles/intel-sdm}
}

@techreport{MASCAB:intel_sdm_v4:17,
  keywords     = KEYWORDS,
  author       = {Intel},
  title        = {{Intel} 64 and {IA-32} architectures software developer's manual volume 4:                            Model-specific registers},
  number       = {335592},
  year         = {2017},
  url          = {http://software.intel.com/en-us/articles/intel-sdm}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/patent}}

@unpublished{MASCAB:Kavi:16,
  keywords     = KEYWORDS,
  author       = {K.M. Kavi},
  title        = {Method and apparatus for improving computer cache performance and for protecting memory systems against some side channel attacks},
  note         = {U.S. Patent Number 13/458,145},
  year         = {2016}
}

@unpublished{MASCAB:Fine:13,
  keywords     = KEYWORDS,
  author       = {K.S. Fine},
  title        = {Detection of side channel attacks between virtual machines},
  note         = {U.S. Patent Number 14/384,677},
  year         = {2013}
}

@unpublished{MASCAB:MulReb:13,
  keywords     = KEYWORDS,
  author       = {D. Mukhopadhyay and C.D. Rebeiro},
  title        = {Resistance to cache timing attacks on block cipher encryption},
  note         = {U.S. Patent Number 14/350,044},
  year         = {2013}
}

@unpublished{MASCAB:RaiGueShe:13,
  keywords     = KEYWORDS,
  author       = {S. Raikin and S. Gueron and G. Sheaffer},
  title        = {Protecting private data from cache attacks},
  note         = {U.S. Patent Number 11/950,963},
  year         = {2013}
}

@unpublished{MASCAB:Williamson:12,
  keywords     = KEYWORDS,
  author       = {B.D. Williamson},
  title        = {Line allocation in multi-level hierarchical data stores},
  note         = {U.S. Patent Number 12/458,690},
  year         = {2012}
}

@unpublished{MASCAB:DolAha:08,
  keywords     = KEYWORDS,
  author       = {B. Dolgunov and A. Aharonov},
  title        = {Memory Randomization For Protection Against Side Channel Attacks},
  note         = {U.S. Patent Number 12/254,225},
  year         = {2008}
}

@unpublished{MASCAB:SebGue:08,
  keywords     = KEYWORDS,
  author       = {J. Sebot and S. Gueron},
  title        = {Mitigating Branch Prediction and Other Timing Based Side Channel Attacks},
  note         = {U.S. Patent Number 11/950,658},
  year         = {2008}
}

@unpublished{MASCAB:BGGKM:07,
  keywords     = KEYWORDS,
  author       = {E.F. Brickell and S. Ghetie and S. Gueron and A. Karrar and F.X. McKeen},
  title        = {Protecting a Branch Instruction from Side Channel Vulnerabilities},
  note         = {U.S. Patent Number 11/951,999},
  year         = {2007}
}

@unpublished{MASCAB:StrJenDhe:07,
  keywords     = KEYWORDS,
  author       = {M. Stribaek and J. Jensen and J.-F. Dhem},
  title        = {Random Cache Line Refill},
  note         = {U.S. Patent Number 11/943,751},
  year         = {2007}
}

@unpublished{MASCAB:Baker:06,
  keywords     = KEYWORDS,
  author       = {B.S. Baker},
  title        = {Avoiding cache line sharing in virtual machines},
  note         = {U.S. Patent Number 11/490,785},
  year         = {2006}
}

@unpublished{MASCAB:MPBC:06,
  keywords     = KEYWORDS,
  author       = {F.X. McKeen and L.K. Puthiyedath and E.F. Brickell and J.B. Crossland},
  title        = {Method and apparatus for preventing software side channel attacks},
  note         = {U.S. Patent Number 11/513,871},
  year         = {2006}
}

@unpublished{MASCAB:NevSei:05,
  keywords     = KEYWORDS,
  author       = {M. Neve and J.-P. Seifert},
  title        = {Resisting cache timing based attacks},
  note         = {U.S. Patent Number 11/302,579},
  year         = {2005}
}

@unpublished{MASCAB:Trostle:04,
  keywords     = KEYWORDS,
  author       = {J.T. Trostle},
  title        = {Timing attacks against user logon and network {I/O}},
  note         = {U.S. Patent Number 10/937,079},
  year         = {2004}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/standard}}

@inproceedings{MASCAB:DOD:85,
  keywords     = KEYWORDS,
  title        = {Trusted Computer System Evaluation Criteria},
  institute    = {Department Of Defence},
  number       = {5200.28-STD},
  year         = {1985},
  url          = {http://csrc.nist.gov/publications/history/dod85.pdf},
  addendum     = {
    Section $8.0$ of the so-called {\sc Orange Book} includes some specific 
    attention to covert channels: it demands a Trusted Computing Base (TCB), 
    which is essentially a security kernel responsible for enforcing policy 
    and supporting isolation, should allow
    ``{\em the capability to audit the use of covert channel mechanisms with bandwidths that may exceed a rate of one ($1$) bit in ten ($10$) seconds}''.
    This definition of what it terms a ``high'' bandwidth covert channel is
    motivated by comparison with the bandwidth of a normal terminal: it says
    ``{\em [i]t does not seem appropriate to call a computer system ``secure'' if information can be compromised at a rate equal to the normal output rate of some commonly used device}''.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/survey}}

@misc{MASCAB:Szefer:16,
  keywords     = KEYWORDS,
  author       = {J. Szefer},
  title        = {Survey of Microarchitectural Side and Covert Channels, Attacks, and Defences},
  howpublished = {Cryptology ePrint Archive, Report 2016/479},
  year         = {2016},
  url          = {http://eprint.iacr.org/2016/479}
}

@misc{MASCAB:GYCH:16,
  keywords     = KEYWORDS,
  author       = {Q. Ge and Y. Yarom and D. Cock and G. Heiser},
  title        = {A Survey of Microarchitectural Timing Attacks and Countermeasures on Contemporary Hardware},
  howpublished = {Cryptology ePrint Archive, Report 2016/613},
  year         = {2016},
  url          = {http://eprint.iacr.org/2016/613}
}

@article{MASCAB:SaiSar:16,
  keywords     = KEYWORDS,
  author       = {R. Vijay Sai and S. Saravanan},
  title        = {A Review on Security in Cache Memories},
  journal      = {Indian Journal of Science and Technology},
  volume       = {9},
  number       = {48},
  pages        = {1--6},
  year         = {2016}
}

@inproceedings{MASCAB:ShaLit:15,
  keywords     = KEYWORDS,
  author       = {A. Shahzad and A. Litchfield},
  title        = {Virtualization Technology: Cross-{VM} Cache Side Channel Attacks make it Vulnerable},
  booktitle    = {Australasian Conference on Information Systems (ACIS)},
  year         = {2015}
}

@article{MASCAB:AciSeiKoc:07,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and J.-P. Seifert and \c{C}.K. Ko\c{c}},
  title        = {Micro-Architectural Cryptanalysis},
  journal      = {IEEE Security \& Privacy}, 
  volume       = {5},
  number       = {4},
  pages        = {62--64},
  year         = {2007}
}

@inproceedings{MASCAB:Tiri:07,
  keywords     = KEYWORDS,
  author       = {K. Tiri},
  title        = {Side-channel Attack Pitfalls},
  booktitle    = {Design Automation Conference (DAC)},
  pages        = {15--20},
  year         = {2007},
  addendum     = {
    This paper sort of surveys the threat of side-channels generally, e.g.,
    to capture and disseminate challenges to the hardware design community.
    However, it has a focus on micro-architectural attacks in Section $2$.
  }
} 

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/book}}

@book{MASCAB:RebMukBha:15,
  keywords     = KEYWORDS,
  author       = {C. Rebeiro and D. Mukhopadhyay and S. Bhattacharya},
  title        = {Timing Channels in Cryptography: A Micro-Architectural Perspective},
  publisher    = {Springer},
  year         = {2015}
}

@incollection{MASCAB:AciKoc:09,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and \c{C}.K. Ko\c{c}},
  title        = {Microarchitectural Attacks and Countermeasures},
  chapter      = {18},
  pages        = {475--504},
  editor       = {{\c{C}.K. Ko\c{c}}},
  booktitle    = {Cryptographic Engineering},
  publisher    = {Springer},
  year         = {2009}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/thesis}}

@phdthesis{MASCAB:Bao:17,
  keywords     = KEYWORDS,  
  author       = {C. Bao},
  title        = {Hardware Attacks And Mitigation Techniques}, 
  school       = {University of Maryland},
  year         = {2017},
  addendum     = {
    In particular, see
    Chapter $4$ (relating to use of 3D integration as a countermeasure against cache-based attacks).
  }
}

@phdthesis{MASCAB:Irazoqui:17,
  keywords     = KEYWORDS,  
  author       = {G. Irazoqui},
  title        = {Cross-core Microarchitectural Side Channel Attacks and Countermeasures}, 
  school       = {Worcester Polytechnic Institute},
  year         = {2017}
}

@phdthesis{MASCAB:Gruss:17,
  keywords     = KEYWORDS,  
  author       = {D. Gruss},
  title        = {Software-based Microarchitectural Attacks}, 
  school       = {Institute of Applied Information Processing and Communications (IAIK), Graz University of Technology},
  year         = {2017}
}

@mastersthesis{MASCAB:Green:17,
  keywords     = KEYWORDS,  
  author       = {M. Green},
  title        = {Implicit Cache Lockdown on {ARM}: An Accidental Countermeasure to Cache-Timing Attacks},
  school       = {Worcester Polytechnic Institute},
  year         = {2017}
}

@phdthesis{MASCAB:Falzon:16,
  keywords     = KEYWORDS,  
  author       = {K. Falzon},
  title        = {On the Use of Migration to Stop Illicit Channels}, 
  school       = {Technischen Universit\"{a}t Darmstadt},
  year         = {2016}
}

@phdthesis{MASCAB:Liu:16,
  keywords     = KEYWORDS,  
  author       = {F. Liu},
  title        = {Cache Side Channel Attacks and Secure Cache Architectures},
  school       = {Princeton University},
  year         = {2016}
}

@phdthesis{MASCAB:Doychev:16,
  keywords     = KEYWORDS,  
  author       = {G. Doychev},
  title        = {Tools for the Evaluation and Choice of Countermeasures against Side-Channel Attacks},
  school       = {Universidad Polit\'{e}cnica De Madrid},
  year         = {2016}
}

@mastersthesis{MASCAB:Lipp:16,
  keywords     = KEYWORDS,  
  author       = {M. Lipp},
  title        = {Cache Attacks and Rowhammer on {ARM}},
  school       = {Institute of Applied Information Processing and Communications (IAIK), Graz University of Technology},
  year         = {2016}
}

@phdthesis{MASCAB:Maurice:15,
  keywords     = KEYWORDS,  
  author       = {C. Maurice},
  title        = {Information leakage on shared hardware: Evolutions in recent hardware and applications to virtualization}, 
  school       = {Institut des Sciences et des Technologies de Paris (ParisTech)},
  year         = {2015}
}

@mastersthesis{MASCAB:Josyula:15,
  keywords     = KEYWORDS,  
  author       = {S.P. Josyula},
  title        = {On the Applicability of a Cache Side-Channel Attack on {ECDSA} Signatures: The {\sc Flush+Reload} attack on the point multiplication in {ECDSA} signature generation process},
  school       = {Blekinge Institute of Technology},
  year         = {2015}
}

@mastersthesis{MASCAB:DAntoine:15,
  keywords     = KEYWORDS,  
  author       = {S.M. D'Antoine},
  title        = {Exploiting Processor Side Channels to Enable Cross {VM} Malicious Code Execution},
  school       = {Rensselaer Polytechnic Institute},
  year         = {2015}
}

@mastersthesis{MASCAB:Svedenborg:14,
  keywords     = KEYWORDS,  
  author       = {S.V. Svedenborg},
  title        = {Exploring Instruction Cache Analysis On {ARM}},
  school       = {Norwegian University of Science and Technology},
  year         = {2014}
}

@mastersthesis{MASCAB:Godfrey:13,
  author       = {M. Godfrey},
  title        = {On the Prevention of Cache-Based Side-Channel Attacks in a Cloud Environment},
  school       = {Queen's University},
  year         = {2013}
}

@phdthesis{MASCAB:Valamehr:13,
  author       = {J.K. Valamehr},
  title        = {Novel Methods of Augmenting High Performance Processors with Security Hardware},
  school       = {University of California, Santa Barbara},
  year         = {2013}
}

@phdthesis{MASCAB:Gallais:11,
  keywords     = KEYWORDS,
  author       = {J.-F. Gallais},
  title        = {Microarchitectural Side-Channel Attacks},
  school       = {University of Luxembourg},
  year         = {2013},
  addendum     = {
    In particular, see
    Chapter $2$ (relating to cache-based attacks), 
    and
    Chapter $4$ (relating to the peripheral topic of hardware Trojans).
  }
}

@phdthesis{MASCAB:Brumley:11,
  keywords     = KEYWORDS,
  author       = {B.B. Brumley},
  title        = {Covert Timing Channels, Caching, and Cryptography},
  school       = {Aalto University},
  year         = {2011}
}

@phdthesis{MASCAB:Grabher:10,
  keywords     = KEYWORDS,
  author       = {P. Grabher},
  title        = {Processor Design Techniques for Efficient and Secure Execution of Cryptographic Algorithms},
  school       = {University of Bristol},
  year         = {2010},
  addendum     = {
    In particular, see
    Chapter $5$ (relating to cache-based attacks on low-power designs),
    and
    Chapter $6$ (relating to cache-based attacks on instruction caches).
  }
}

@mastersthesis{MASCAB:Gay:08,
  keywords     = KEYWORDS,  
  author       = {R. Gay},
  title        = {Interrupt-related Covert Channels from an Attackers Perspective},
  school       = {Aachen University},
  year         = {2008}
}

@phdthesis{MASCAB:Aciicmez:07:a,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez},
  title        = {Advances in side-channel cryptanalysis: Microarchitectural attacks},
  school       = {Oregon State University}, 
  year         = {2007}
}

@phdthesis{MASCAB:Neve:06,
  keywords     = KEYWORDS,
  author       = {M. Neve},
  title        = {Cache-based Vulnerabilities and {SPAM} analysis},
  school       = {Universit\'{e} catholique de Louvain}, 
  year         = {2006}
}

@mastersthesis{MASCAB:Huang:10,
  keywords     = KEYWORDS,
  author       = {B. Huang},
  title        = {Cache-collision timing attacks against {AES-GCM}},
  school       = {University of Delaware},
  year         = {2010}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=misc/software}}

@unpublished{MASCAB:Mastik,
  keywords     = KEYWORDS,
  author       = {Y. Yarom},
  title        = {{Mastik}: a micro-architectural side-channel toolkit},
  url          = {http://cs.adelaide.edu.au/~yval/Mastik/}
}

@unpublished{MASCAB:TRICL,
  keywords     = KEYWORDS,
  author       = {C. Percival},
  title        = {{TRICL}: a timing attack resistant cryptographic library},
  url          = {http://www.daemonology.net/tricl}
}

% =============================================================================
@STRING{KEYWORDS={class=channel/covert,topic=neg}}

@article{MASCAB:NagAbu:17,
  keywords     = KEYWORDS,
  author       = {H. Naghibijouybari and N. Abu-Ghazaleh},
  title        = {Covert Channels on {GPGPUs}},
  journal      = {IEEE Computer Architecture Letters}, 
  volume       = {16},
  number       = {1},   
  pages        = {22--25},
  year         = {2017},
  addendum     = {
    This paper constructs a contention-based covert channel, using either L1
    or L2 caches on a specific, Nvidia-based GPU; this permits communication
    within or between constituent streaming multi-processors.
  }
}

% =============================================================================
@STRING{KEYWORDS={class=channel/side/cache,style=dcache/access,topic=neg/method}}

@inproceedings{MASCAB:DKPT:17,
  keywords     = KEYWORDS,
  author       = {C. Disselkoen and D. Kohlbrenner and L. Porter and D. Tullsen},
  title        = {{\sc Prime+Abort}: A Timer-Free High-Precision {L3} Cache Attack using {Intel} {TSX}},
  booktitle    = {Computer and Communications Security (CCS)},
  pages        = {51--67},
  year         = {2017},
  addendum     = {
    Within the context of access-driven cache attacks,
    this paper presents an attack        technique which harnesses the Intel 
    transactional memory, or TSX feature.
    The technique moniker {\sc Prime+Abort} hints at the underlying idea: it
    is basically similar to {\sc Prime+Probe}, but, rather than interrogate
    residency of some target address by timing the execution of a ``probe'' 
    access, it makes use of TSX.  More specifically, the attacker primes TSX
    wrt. the target address st. access to it by the target process causes a
    transaction abort; this essentially triggers the attack process, which 
    can then act accordingly.  Section $3$ overviews several strategies in 
    more detail, but some high-level advantages and disadvantages are common
    to most:
    a) there is no need for a timer, also implying the side-channel involves
       less noise,
    b) there is no need for synchronisation with or detection of the target
       process: the attack process can essentially just wait, until it is
       triggered {\em precisely} when the target process performs an access,
    c) it is harder to cope with (i.e., multiplex) multiple target addresses.

    Note that Figure $1$ offers a neat comparison of different attack styles,
    wrt. a variety of properties, and that~\cite{MASCAB:JanLeeKim:16} use the
    same sort of technique to target KASLR.
  }
}

@inproceedings{MASCAB:ABFPY:16,
  keywords     = KEYWORDS,
  author       = {T. Allan and B.B. Brumley and K. Falkner and J. van de Pol and Y. Yarom}, 
  title        = {Amplifying Side Channels Through Performance Degradation},
  booktitle    = {Annual Computer Security Applications Conference (ACSAC)},
  pages        = {},
  year         = {2016},
  addendum     = {
    There is a central idea in this paper, then used in a second step so as
    to mount an (improved) attack on OpenSSL-based ECDSA.  Essentially, the 
    idea is to execute a process dedicated to aggressively evicting content
    associated with a target; this increases the latency of memory accesses
    and thus execution time, so degrading performance.  The {\em reason} to
    do is is that increased execution time thereby allows a higher-fidelity
    measurement within, for example, {\sc Prime+Probe} style, access-driven 
    cache attacks wrt. the LLC.
  }
}

@inproceedings{MASCAB:GruSprMan:15,
  keywords     = KEYWORDS,
  author       = {D. Gruss and R. Spreitzer and S. Mangard},
  title        = {Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches},
  booktitle    = {USENIX Security Symposium},
  pages        = {897--912},
  year         = {2015},
  addendum     = {
    In a sense, this paper generalises and adds some degree of automation to
    {\sc Flush+Reload} attack style, access-driven cache attacks (as hinted
    by the title, wrt. inclusive LLCs).  A central idea stems from DPA-style 
    template attacks: the attack is in two phases, namely
    1) a profiling (or characterisation) phase (Section $3.1$)
       where, for each event of interest, {\sc Flush+Reload} is applied to 
       each address in the (controlled) target; this yields a template wrt. 
       the event, which is essentially a profile of related cache activity,
       then
    2) an exploitation                   phase (Section $3.2$)
       where the real target is executed: {\sc Flush+Reload} is applied to 
       each address, and the resulting profile compared (using a suitable
       similarity metric) to the corpus of templates st. the event can be
       identified.
    The concept of an event is described in the abstract: it could be 
    a) high-level, e.g., a key-press within some application, 
       or 
    b)  low-level, e.g., a table access,
    for example.  The paper harnesses the concept to mount various concrete
    attacks, e.g., on both Linux and Windows UI (Sections $5.1$ and $5.3$),
    and AES as implemented by OpenSSL (Section $5.4$).
  }
} 

@article{MASCAB:GruMauWag:15,
  keywords     = KEYWORDS,
  author       = {D. Gruss and C. Maurice and K. Wagner},
  title        = {{\sc Flush+Flush}: {A} Stealthier Last-Level Cache Attack},
  journal      = {CoRR},
  volume       = {abs/1511.04594},
  year         = {2015},
  url          = {http://arxiv.org/abs/1511.04594},
  addendum     = {
    Although the title suggests a focus on the latter, this paper makes three
    main contributions: it
    1) analyses the use of performance counters as a means of (dynamically, 
       at run-time) detecting cache-based side-channel attack; this suggests
       measuring last-level cache misses and references is enough,
    2) formulates a metric for said detection that normalises wrt. the size
       of kernel (since an attack process exhibits behaviour in the cache via
       a tight attack loop),
       and
    3) following roughly the same model as {\sc Flush+Reload}, an alternative
       attack strategy, namely {\sc Flush+Flush}, is presented: the strategy 
       hinges on the fact that {\tt clflush} has address-dependent execution
       time (longer if an inclusive flush is required, shorter if not: this
       is sort of the opposite to a cache hit and cache miss, since it needs
       longer to flush if the data is resident), so it is possible to replace 
       the reload memory access with a second use of {\tt clflush} and hence
       a) has a faster attack loop since {\tt clflush} has lower latency than 
          memory access (although this also implies lower fidelity, since the 
          difference in latency is also less),
       b) is less invasive, in the sense flushes do not trigger prefetching
          (vs. a reload, which, since it is a memory access, {\em does}),
          and
       c) is more stealthy, since flushes do not count as cache misses.
     The attack is evaluated by applying it in a range of contexts, e.g., to 
     perform input distinguishing (Section $VI$) wrt. GTK, and recovery of 
     cryptographic keys (Section $VII$) wrt. AES as implemented by OpenSSL.
     There are some further insights into {\tt clflush} itself in Section
     $VIII$, and a detailed comparison of countermeasure techniques within
     Section $IX$.
  }
}

@inproceedings{MASCAB:YarFal:14,
  keywords     = KEYWORDS,
  author       = {Y. Yarom and K. Falkner},
  title        = {{\sc Flush+Reload}: A High Resolution, Low Noise, {L3} Cache Side-channel Attack},
  booktitle    = {USENIX Security Symposium},
  pages        = {719--732},
  year         = {2014},
  addendum     = {
    This paper introduces the {\sc Flush+Reload} attack strategy (or, as
    \cite{MASCAB:GulBanKre:11} describe but do not name what is basically
    the same approach, {\em re}introduces): crucially,
    this approach
    a) targets the LLC (modulo issues such as inclusivity),
       so
    b) permits inter-core attacks st. an attack process executing on one 
       core can attack a target process executing on another; this allows 
       relaxation of previous restrictions on core co-residency, and thus
       enables cross-VM attacks (modulo issues such as shared memory, via 
       de-duplication).
    The attack strategy could be viewed as a variant of {\sc Prime+Probe},
    in the sense it assumes access to a shared memory region but uses the
    x86-based {\em clflush} instruction to prime (i.e., {\em invalidate}) 
    specific cache lines; Figure $4$ supports a detailed overview of the
    attack process kernel, noting the need for memory fences to serialise
    memory accesses (and the caveat wrt. using {\tt cpuid} instead, which
    may in fact be virtualised).  Section $4$ applies the strategy to the
    GnuPG implementation of RSA, probing addresses in modular squaring
    and multiplication functions to distinguish the two and hence recover
    bits of a $2048$-bit exponent based on which they are invoked.
  }
} 

@inproceedings{MASCAB:GulBanKre:11,
  keywords     = KEYWORDS,
  author       = {D. Gullasch and E. Bangerter and S. Krenn},
  title        = {Cache Games -- Bringing Access-Based Cache Attacks on {AES} to Practice},
  booktitle    = {IEEE Symposium on Security \& Privacy (S\&P)},
  pages        = {490--505}, 
  year         = {2011},
  addendum     = {
    This paper extends the state-of-the-art in access-driven cache attacks in
    several ways.  In particular, it
    a) introduces a new attack strategy, which is {\sc Flush+Reload}-esque in
       the sense it uses a combination of {\tt clflush} and (timed) access to
       memory, but targets the L1 cache,
    b) makes use of a form of performance degradation, forcing the target to
       execute for an abnormally short time quantum: by (ab)using the Linux
       CFS, the attack process forces this behaviour so as to isolate as few
       as a single memory access by the target and so obtain very ``clean''
       samples.
    The paper provides some additional contributions, among which are use of
    a neural network in order to combat the effect of noise.  In combination,
    the performance degradation and neural network approaches mean the attack
    can succeed in a totally asynchronous setting: this improves over
    {\sc Evict+Time}
    {\em and} 
    {\sc Prime+Probe}
    per~\cite{MASCAB:TroOsvSha:10}.
  }
}

@unpublished{MASCAB:BanGulKre:10,
  keywords     = KEYWORDS,
  author       = {E. Bangerter and D. Gullasch and S. Krenn},
  title        = {Cache Games -- Bringing Access Based Cache Attacks on {AES} to Practice},
  howpublished = {Cryptology ePrint Archive, Report 2010/594},
  year         = {2010},
  url          = {\url{http://eprint.iacr.org/2010/594}},
  addendum     = {
    This is an older version of~\cite{MASCAB:GulBanKre:11};
    although the newer version is most relevant, this older version remains
    important in specific cases due to (minor) differences in content.
  }
}

@inproceedings{MASCAB:TroOsvSha:10,
  keywords     = KEYWORDS,
  author       = {E. Tromer and D.A. Osvik and A. Shamir},
  title        = {Efficient Cache Attacks on {AES}, and Countermeasures},
  journal      = {Journal of Cryptology},
  publisher    = {Springer-Verlag},
  volume       = {23},
  number       = {1},
  pages        = {37--71},
  year         = {2010},
  addendum     = {
    This paper offers a number of seminal contributions.  For example, it
    1) formalises terminology wrt. synchronous vs. asynchronous attacks,
    2) introduces both the 
       {\sc Evict+Time}  (Section $3.4$)
       {\em and} 
       {\sc Prime+Probe} (Section $3.5$)
       attack strategies, applying variants of them to AES implementations
       within OpenSSL and the Linux {\tt dm-crypt} disk encryption system;
       both implementations depend on quasi-parallel execution (in this
       case via x86-based HypherThreading), and target activity in the L1 
       (and to a lesser extent L2, or at least not shared between core and
       so not LLC) cache,
    3) offers a detailed survey of potential countermeasures (Section 5),
       and
    4) makes several wider predictions and comments, such as the fact
       ``bank collisions (e.g., in Athlon 64 processors) likewise cause timing to be affected by low address bits''.
  }
}

@inproceedings{MASCAB:OsvShaTro:06,
  keywords     = KEYWORDS,
  author       = {D.A. Osvik and A. Shamir and E. Tromer},
  title        = {Cache Attacks and Countermeasures: The Case of {AES}},
  booktitle    = {Topics in Cryptology (CT-RSA)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 3860},
  pages        = {1--20},
  year         = {2005},
  addendum     = {
    This is an older version of~\cite{MASCAB:TroOsvSha:10};
    although the newer version is most relevant, this older version remains
    important in specific cases due to (minor) differences in content.
  }
}

@unpublished{MASCAB:Percival:05:b,
  keywords     = KEYWORDS,
  author       = {C. Percival},
  title        = {Cache Missing For Fun And Profit},
  year         = {2005},
  url          = {http://www.daemonology.net/papers/cachemissing.pdf},
  addendum     = {
    This is a seminal paper, which 
    1) introduces the {\sc Prime+Probe} attack strategy, targeting either 
       L1 or L2 cache of a Pentium $4$ core using an attack process that
       executes in quasi-parallel (via x86-based HypherThreading) with 
       the target process,
       and
    2) applies this to the RSA implementation in OpenSSL; since this uses
       the CRT and sliding window exponentiation, some effort is required
       to perform key recovery (i.e., the attack recovers $\sim 300$ of 
       $512$ bits of $p$ and $q$, so an approach is needed to recover the
       rest via a post-processing phase).
    This alone is important (contemporary attacks were against symmetric
    targets such as block ciphers), but the paper also includes various
    additional details of interest: a central example is the detailed 
    attack process in Figure $1$ that
    a) copes with influence of the prefetch system,
    b) copes with latency of {\tt rdtsc} by artificially elongating the
       critical path using extra, dependent instructions.
  }
}

@unpublished{MASCAB:Percival:05:a,
  keywords     = KEYWORDS,
  author       = {C. Percival},
  title        = {Cache Missing For Fun And Profit},
  year         = {2005},
  url          = {http://www.daemonology.net/papers/htt.pdf},
  addendum     = {
    This is an older version of~\cite{MASCAB:Percival:05:b};
    although the newer version is most relevant, this older version remains
    important in specific cases due to (minor) differences in content.
  }
}

% .............................................................................
@STRING{KEYWORDS={class=channel/side/cache,style=dcache/access,topic=neg/attack/crypto}}

@inproceedings{MASCAB:GarBru:17,
  keywords     = KEYWORDS,
  author       = {C.P. Garc\'{i}a and B.B. Brumley},
  title        = {Constant-Time Callees with Variable-Time Callers},
  booktitle    = {USENIX Security Symposium},
  pages        = {83--98},
  year         = {2017},
  addendum     = {
    This paper mounts a {\sc Flush+Reload} style, access-driven cache attack
    on OpenSSL-based ECDSA.  Although this has been targeted previously, the
    paper proceeds in a somewhat different manner:
    a) noticing a supposed countermeasure (a constant-time implementation of
       binary EEA) was not activated due to a bug wrt. propogation of flags
       (embedded as meta-data in the multi-precision integer object),
    b) attacking the binary EEA (vs. scalar multipliplication) in ECDSA, and
       thus recovering inputs (the ephemeral key, or nonce $k$) via a shift 
       and subtraction sequence in turn recovered from the cache attack
       (cf.~\cite{MASCAB:AciGueSei:07} and \cite{MASCAB:AraThu:07} who use
       side-channels based on branch prediction and power analysis with the
       same goal),
    c) enhancing the robustness of this approach by employing performance 
       degredation~\cite{MASCAB:ABFPY:16},
    d) recovering the ECDSA signing key from a set of ephemeral keys using
       a final, lattice-based cryptanalytic step.
  }
}

@inproceedings{MASCAB:GarBruYar:16,
  keywords     = KEYWORDS,
  author       = {C.P. Garc\'{i}a and B.B. Brumley and Y. Yarom},
  title        = {Make Sure {DSA} Signing Exponentiations Really are Constant-Time},
  booktitle    = {Computer and Communications Security (CCS)},
  pages        = {1639--1650},
  year         = {2016},
  addendum     = {
    An observation, namely identification of a bug, enables contributions of
    this paper.  OpenSSL included a new flag to each multi-precision integer 
    representation, indicating whether or not it is deemed security-critical 
    (e.g., is an RSA private exponent); the flag is used to select either a
    variable- or constant-time exponentiation implementation.  This property
    {\em should} be propagated through arithmetic operations, but, it turns
    out, is {\em not} due to a bug (or at least poor API design).  This fact 
    is harnessed in an attack against OpenSSL DSA implementation, combining 
    use of
    a) performance degradation, 
    b) a {\sc Flush+Reload} style, access-driven cache attack wrt. the LLC,
       plus
    c) a lattice-based key recovery phase;
    the attack is applied both to TLS and SSH.
  }
}

@inproceedings{MASCAB:YarGenHen:16,
  keywords     = KEYWORDS,
  author       = {Y. Yarom and D. Genkin and N. Heninger},
  title        = {{CacheBleed}: A Timing Attack on {OpenSSL} Constant Time {RSA}},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9813}, 
  pages        = {346--367}, 
  year         = {2016},
  addendum     = {
    To address~\cite{MASCAB:Percival:05b}, Intel contributed an implementation
    of the scatter-gather countermeasure to OpenSSL; it basically patched the
    sliding window based modular exponentiation function as used by RSA.  The
    original attack was able to distinguish between pre-computed values (thus
    inferring bits of the exponent used to select them) because they mapped to 
    different cache lines; scatter-gather interleaves said values (in a sense
    transposing them in memory), st. the {\em same} cache lines are accessed
    irrespective of the value.  This is based on intuition which suggests the
    latency of access leaks no information below cache line granularity.

    This paper effectively defeats the scatter-gather countermeasure.  Using
    the fact (per ~\cite{MASCAB:Bernstein:05} and~\cite{MASCAB:TroOsvSha:10})
    bank conflicts alter the latency of access to the L1 cache, the intuition
    above is invalidated: an attack process intentionally constructed to probe
    a specific bank can monitor access to that bank by the target (by virtue 
    of the resulting difference in latency of access), and so infer associated
    access {\em within} some cache line.  This approach is harnessed to mount
    a concrete attack, which requires some post-processing to cope with the
    (relatively) low number of exponent bits recovered and thereby perform key
    recovery.
  }
}

@inproceedings{MASCAB:BHLY:16,
  keywords     = KEYWORDS,
  author       = {L.G. Bruinderink and A. H\"{u}lsing and T. Lange and Y. Yarom},
  title        = {{Flush}, {Gauss}, and {Reload} - A Cache Attack on the {BLISS} Lattice-Based Signature Scheme},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9813}, 
  pages        = {323--345}, 
  year         = {2016}
}

@inproceedings{MASCAB:ZanXiaZha:16,
  keywords     = KEYWORDS,
  author       = {X. Zhang and Y. Xiao and Y. Zhang},
  title        = {Return-Oriented Flush-Reload Side Channels on {ARM} and Their Implications for {Android} Devices},
  booktitle    = {ACM Conference on Computer and Communications Security (CCS)},
  pages        = {858--870},
  year         = {2016},
  addendum     = {
    The focus of this paper is the application of {\sc Flush+Reload}-style, 
    access-driven cache attacks on ARM-based devices executing Android; the
    L2 cache (i.e., LLC) is used as a target.
    A range of challenges are address, but there are effectively three main
    contributions:
    1) Although user-mode processes cannot directly control the caches, the
       OS provides the {\tt clearcache} system call to {\em clean} the data 
       cache (i.e., write-back) and {\em flush} the instruction cache; in a
       sense, this permits {\tt clflush}-like behaviour for the instruction   
       cache only.  A characterisation of this system call, and user-mode
       timers (since ARM also lacks a user-mode {\tt tdtsc})) is presented.
    2) {\sc Flush+Reload} attacks are them mounted using {\tt clearcache},
       targeting the instruction cache.  The most interesting aspect here
       is the use of Return Oriented Programming (ROP) gadgets as a means
       of reloading: calling a ``full'' target function is problematic in
       the sense
       a) a sane caller context (e.g., parameters) must be constructed,
       b) the achievable granularity of the attack may be to low to capture
          the function if the associated execution time is short.
       Instead, the idea is to use ROP gadgets as a proxy for the function 
       itself: these need no context and, by definition, will have a short 
       execution time (of a few cycles typically: automatically returning 
       after a few instructions).
    3) The attack is leveraged to target some real-world Android use-cases,
       including detection of hardware and UI events.
  }    
} 

@inproceedings{MASCAB:LGSM:16,
  keywords     = KEYWORDS,
  author       = {M. Lipp and D. Gruss and R. Spreitzer and S. Mangard},
  title        = {{ARMageddon}: Last-Level Cache Attacks on Mobile Devices},
  booktitle    = {USENIX Security Symposium},
  pages        = {549--564},
  year         = {2016},
  addendum     = {
    The application of access-driven, cache-based side-channel attacks to 
    an ARM processor implies various challenges: for example,
    a) ARM use a random replacement policy, which complicates the challenge
       of interrogating residency of some target data (i.e., by introducing 
       noise),
    b) the ARM-based analogy of the x86 Time-Stamp Counter (TSC) can only be
       used in user mode {\em if} permission is granted from kernel mode,
    c) a dedicated flush instruction can only be executed in kernel mode,
       and
    d) ARM use an LLC that is not inclusive (i.e., data resident in the L1
       cache is not guaranteed to be resident in the LLC), which differs 
       from various alternatives.
    This paper addresses these challenges, mounting {\sc Prime+Probe} and 
    {\sc Evict+Reload} style, access-driven cache attacks on the Android 
    touch-screen interface (in order to recover tap and swipe events), and 
    BouncyCastle AES implementation.
  }
}

% .............................................................................
@STRING{KEYWORDS={class=channel/side/cache,style=dcache/access,topic=neg/attack/ui}}


@inproceedings{MASCAB:Hornby:16,
  keywords     = KEYWORDS,
  author       = {T. Hornby},
  title        = {Side-Channel Attacks on Everyday Applications: Distinguishing Inputs with {\sc Flush+Reload}},
  booktitle    = {BlackHat USA},
  year         = {2016},
  url          = {http://www.defuse.ca/side-channel-attacks-on-everyday-applications.htm},
  addendum     = {
    This paper shifts the target of side-channel attack from key recovery to
    privacy; the main contribution is a {\sc Prime+Probe} style, access-driven 
    cache attacks used as an input distinguisher (e.g., to determine web-site 
    access by Links, or which PDF loaded by libpoppler, or whether a TrueCrypt 
    volume contains a hidden volume).  This alone is interesting, but Section 
    $3.1$ offers an additional contribution, (briefly) outlining an approach 
    to automate selection of probe addresses.
  }
}

% .............................................................................
@STRING{KEYWORDS={class=channel/side/cache,style=dcache/access,topic=neg/attack/iee}}

@article{MASCAB:MogIraEis:17,
  keywords     = KEYWORDS,
  author       = {A. Moghimi and G. Irazoqui and T. Eisenbarth},
  title        = {{CacheZoom}: How {SGX} Amplifies The Power of Cache Attacks},
  journal      = {CoRR},
  volume       = {arXiv:1703.06986},
  year         = {2017},
  url          = {http://arxiv.org/abs/1703.06986},
  addendum     = {
    This paper present an attack strategy termed {\sc CacheZoom}; it operates
    within the context of SGX, allowing attack of a target enclave, applying
    an access-driven cache attack based on {\sc Prime+Probe} to the L1 cache.
    By mounting a key-recovery attack on an AES implementation that executes
    within the target enclave, 
    a) the remit matches that of~\cite{MASCAB:GESM:17,MASCAB:BMDKCS:17},
       and
    b) elements of the strategy are similar: the attacker-controlled kernel
       manipulates the scheduler to determine which core the target enclave
       and attack process execute on, for example.
    However, the strategy {\em also} differs significantly in the sense that 
    it intentionally interrupts the target enclave; by doing so on (upto) a
    per instruction basis, noise that may impact on inspection of the cache
    state (i.e., the probe step).  This is achieved using the APIC deadline 
    mode, and, per Section $6.1.1$, can eliminate the effect of pre-warming
    countermeasures because the per instruction fidelity allows it to be
    skipped or even ``undone'' before execution of AES itself.
  }
}

@inproceedings{MASCAB:GESM:17,
  keywords     = KEYWORDS,
  author       = {J. G\"{o}tzfried and M. Eckert and S. Schinzel and T. M\"{u}ller},
  title        = {Cache Attacks on {Intel} {SGX}},
  booktitle    = {European Workshop on System Security (EuroSec)},
  pages        = {2:1--2:6},
  year         = {2017},
  addendum     = {
    As noted in Section $1.2$, this paper was developed concurrently with 
    \cite{MASCAB:SWGMM:17}
    and
    \cite{MASCAB:BMDKCS:17};
    whatever the timing, it {\em seems} to represent the first peer-reviewed
    publication relating to cache-based side-channel attacks on SGX.
    The context is similar to \cite{MASCAB:BMDKCS:17}, in that the goal is a
    key-recovery attack on a workload executed in an SGX enclave; the target
    is a T-tables style AES implementation realised in OpenSSL already known
    to be vulnerable.  A {\sc Prime+Probe} style, access-driven cache attack
    is used (with an elimination-based~\cite{MASCAB:NevSei:06} strategy for
    key-recovery) wrt. the L1 cache.  Versus \cite{MASCAB:BMDKCS:17}, there
    are also similarities in terms of the approach, e.g., wrt. performance
    counters for noise-free measurement, and attack-friendly scheduling and
    core allocation by a malicious kernel.

    Section $4.2$ offers some interesting insights:
    1) although the Intel ASCI~\cite[Section 42.6]{MASCAB:intel_sdm_v3:17} 
       feature can prevent leakage from the enclave via performance counters, 
       their use by a malicious kernel for probing avoids this restriction,
       and
    2) the Intel SDK for SGX utilises an implementation of AES that does not
       harness AES-NI, which would be the obvious countermeasure against such
       attacks, which seems an odd choice.
  }
}

@article{MASCAB:SWGMM:17,
  keywords     = KEYWORDS,
  author       = {M. Schwarz and S. Weiser and D. Gruss and C. Maurice and S. Mangard},
  title        = {Malware Guard Extension: Using {SGX} to Conceal Cache Attacks},
  journal      = {CoRR},
  volume       = {abs/1702.08719},
  year         = {2017},
  url          = {http://arxiv.org/abs/1702.08719},
  addendum     = {
    This paper describes a malware concept, where an attack process executes
    within an SGX enclave.  The idea is to mount a {\sc Prime+Probe} style, 
    access-driven cache attack on some target process (e.g., as executed in
    another enclave); per Figure $2$, for example, the attack hinges on the 
    fact that accesses from the attack enclave will interact, wrt. the LLC, 
    with those from the target.
    On one hand, doing so is intuitively feasible: each enclave is isolated
    wrt. various potential interactions, but also share micro-architectural
    resources with the surrounding system.  As a result, Intel exclude such
    attacks from the SGX security model, so in a sense view them as out of 
    scope (e.g., see \cite[Section 6.6]{MASCAB:CosDev:16}).  
    However, on the other hand, some complicating factors exist; the paper
    addresses these to provide practical evidence of this intuition.  For 
    example:
    a) Within an enclave, the x86 Time-Stamp Counter (TSC) is not available;
       to provide a high-resolution timer a counter-based thread (see also
       \cite{MASCAB:LGSM:16}) is used, which, via some optimisation, offers
       {\em sub}-cycle accuracy.
    b) The address space of an enclave (formed from a sub-set of the virtual
       address space of the associated process) is backed by protected (e.g.,
       encrypted) physical page frames; since the attacker cannot translate 
       virtual addresses to their physical equivalent, eviction of specific 
       cache sets (as required for {\sc Prime+Probe}) is more complicated.
       The paper develops a novel approach for deriving the cache set for a
       given virtual address; this is based on use of timing differences
       that occur due to bank conflicts during access to physical memory.

    Beyond this, some more subtle points seem important to stress:
    1) it seems fair to {\em not} classify this as an attack on SGX per se,
       but rather on the premise that SGX cannot be subverted for malign
       purposes,
    2) an enclave is, by definition, a black box: isolating an enclave from 
       other components is a positive in benign use-cases, but then becomes 
       a negative in malign alternatives, e.g., since the malware cannot be
       detected by conventional means,
       and
    3) there has been some critique\footnote{
         See, e.g., \url{http://jbeekman.nl/blog/2017/03/sgx-side-channel-attacks}.
       } of the attack target, in the sense that although mbedTLS harnesses
       a constant-time modular multiplication the exponentiation attacked is 
       based on square-and-multiply (despite mbedTLS including side-channel 
       resistant alternatives); although a reasonable criticism, it does not
       seem to detract from the concept {\em or} impact of the points above.
  }
}

@article{MASCAB:BMDKCS:17,
  keywords     = KEYWORDS,
  author       = {F. Brasser and U. M\"{u}ller and A. Dmitrienko and K. Kostiainen and S. Capkun and A.-R. Sadeghi},
  title        = {Software Grand Exposure: {SGX} Cache Attacks Are Practical},
  journal      = {CoRR},
  volume       = {abs/1702.07521},
  year         = {2017},
  url          = {http://arxiv.org/abs/1702.07521},
  addendum     = {
    This paper describes an attack on a target process (so, more accurately,
    a target enclave) which executes with support from SGX.
    In line with the SGX security model, the attacker is able
    to control the surrounding system; per Figure $2$, for example, it thus
    mounts a {\sc Prime+Probe} style (using either L1 or L2 caches, but not
    LLC), access-driven cache attack on the target.  
    On one hand, doing so is intuitively feasible: each enclave is isolated
    wrt. various potential interactions, but also share micro-architectural
    resources with the surrounding system.  As a result, Intel exclude such
    attacks from the SGX security model, so in a sense view them as out of 
    scope (e.g., see \cite[Section 6.6]{MASCAB:CosDev:16}).  
    However, on the other hand, some complicating factors exist; the paper
    addresses these to provide practical evidence of this intuition.  Much
    of the complication stems from noise.  For example, in addition to the
    inherent, experimental noise wrt. timing measurement, pollution of the
    cache state will degrade the validity of said measurements:
    1) there is inherent intra-process pollution,
    2) other processes may use the same core as the target process and thus
       cause inter-process pollution, and
    3) any interrupt will cause an Asynchronous Enclave Exit (AEX), activity
       related to which may pollute the cache.
    Section $4.3$ describes a series of mitgations for these issues.  Some
    are fairly obvious (e.g., limiting those processes scheduled to execute
    on the target core), but some fairly novel: use of performance counters
    to offer noise-free measurement of cache behaviour avoids disadvantages
    in~\cite{MASCAB:UhsGeoVer:08}, for example, due to the SGX security 
    model.

       There has been some critique\footnote{
         See, e.g., \url{http://jbeekman.nl/blog/2017/03/sgx-side-channel-attacks}.
       } of the attack target, i.e., the RSA implementation provided in the 
       Intel SDK for SGX.  Specifically, the target is assumed to make use
       of an insecure, fixed-window exponentiation rather than a hardened
       variant (cf. Section $1$, Page $2$) also provided; the criticism is
       that the former is intended for public-key operations so key recover
       is moot.  Arguably there are some counter-arguments: 
       1) if the API allows such mistakes, the API is badly designed (or
          at least could or {\em should} be better),
       2) although valid, such an argument does not (necessarily) detract 
          from the high-level take away point and techniques involved.
       In respect to the latter, in Section $6$ the paper also includes an
       attack against the non-cryptographic workload of genomic processing.
  }
}

@unpublished{MASCAB:ZSSLH:16,
  keywords     = KEYWORDS,
  author       = {N. Zhang and K. Sun and D. Shands and W. Lou and Y.T. Hou},
  title        = {{TruSpy}: Cache Side-Channel Information Leakage from the Secure World on {ARM} Devices},
  howpublished = {Cryptology ePrint Archive, Report 2016/980},
  year         = {2016},
  url          = {http://eprint.iacr.org/2016/980},
  addendum     = {
    Set within the context of ARM TrustZone, this paper essentially shows the
    NS bit does {\em not} prevent a non-secure attacker mounting cache-based 
    attacks on a secure target.  Put another way, the NS bit prevents access,
    but {\em not} eviction: the non-secure attacker can interrogate residency  
    of content relating to the secure target, by using the approach of timing 
    (controlled) eviction as per {\sc Prime+Probe}.  The paper harnesses this 
    fact to mount concrete attacks on OpenSSL-based AES, via the L1 cache (so 
    avoiding issues such as inclusivity), using an interrupt-based (vs. the 
    x86 time stamp counter, for example) method for timing accesses.
  }
}

@inproceedings{MASCAB:Brumley:15,
  keywords     = KEYWORDS,
  author       = {B.B. Brumley},
  title        = {Cache Storage Attacks},
  booktitle    = {Topics in Cryptology (CT-RSA)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9048},
  pages        = {22--34},
  year         = {2015},
  addendum     = {
    This paper focuses first on a covert channel predicated on the NS bit in
    ARM-based caches: based on the storage channel paradigm, the idea is for
    a channel to be formed between a (insecure) sender and (secure) receiver
    by
    1) the receiver priming the cache with (insecure) content,
    2) the sends evicts some of that content, say wrt. an address $x$, thus
       replacing with with (secure) content of their own,
    3) the receiver probes the cache: when they access address $x$ this is
       disallowed, causes an interrupt and thus completes transmission.
    This general approach is then translated into the side-channel setting,
    where an access-driven attack using a similar principle is presented; an
    advantage of this is the strong signal is exhibits (vs. use of timing to
    interrogate residency), but a disadvantage seems to be the need to use
    physical addresses since the probe stage need to specifically access $x$ 
    (vs. some congruent $x'$) to violate the access permissions.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=neg,style=dcache/time}}

@inproceedings{MASCAB:JiaFeiKae:16,
  keywords     = KEYWORDS,
  author       = {Z.H. Jiang and Y. Fei and D. Kaeli},
  title        = {A complete key recovery timing attack on a {GPU}},
  booktitle    = {High Performance Computer Architecture (HPCA)},
  pages        = {394--405},
  year         = {2016},
  addendum     = {
    This paper presents a cache-based timing attack on AES: per Figure $1$,
    the context is similar to analogous remote timing attacks, except that
    the target executes AES using a GPU (vs. a CPU).  As such, the central 
    observation is that on the experimental Nvidia-based GPU, for example,
    execution time is correlated with L1 cache behaviour.
  }
} 

@inproceedings{MASCAB:BHNS:10,
  keywords     = KEYWORDS,
  author       = {B.B. Brumley and R.M. Hakala and K. Nyberg and S. Sovio},
  title        = {Consecutive {S-box} Lookups: A Timing Attack on {SNOW 3G}},
  booktitle    = {Information and Communications Security (ICICS)}, 
  publisher    = {Springer-Verlag},
  series       = {LNCS 6476},
  pages        = {171--185},
  year         = {2010}
}

@unpublished{MASCAB:ZhaWanZhe:09,
  keywords     = KEYWORDS,
  author       = {X.-J. Zhao and T. Wang and Y.-Y. Zheng},
  title        = {Cache Timing Attacks on {Camellia} Block Cipher},
  note         = {Cryptology ePrint Archive, Report 2009/354},
  year         = {2009},
  url          = {http://eprint.iacr.org/2009/354},
}

@inproceedings{MASCAB:LeaZenHaw:09,
  keywords     = KEYWORDS,
  author       = {G. Leander and E. Zenner and P. Hawkes},
  title        = {Cache Timing Analysis of {LFSR}-based Stream Ciphers},
  booktitle    = {Cryptography \& Coding},
  publisher    = {Springer-Verlag LNCS 5921},
  pages        = {433--445},
  year         = {2009}
}

@inproceedings{MASCAB:Zenner:08,
  keywords     = KEYWORDS,
  author       = {E. Zenner},
  title        = {A Cache Timing Analysis of {HC-256}},
  booktitle    = {Selected Areas in Cryptography (SAC)}, 
  publisher    = {Springer-Verlag},
  series       = {LNCS 5381},
  pages        = {199--213},
  year         = {2008},
  addendum     = {
    Perhaps more interesting than the attack on HC-256 in this paper, is the
    fact that
    1) it applies to a stream cipher, whereas other attacks focus either on
       block ciphers (e.g., AES) or RSA almost exclusively; in a sense, the
       paper extends the remit of micro-architectural attacks,
    2) Section $5.2$ includes a discussion of security-by-design, i.e., the
       idea of (re)designing a stream cipher to offer explicit by-design vs. 
       after-the-fact, ``patched'' countermeasures,
       and, perhaps most importantly,
    3) Section $6$ generalises the attack model, allowing analysis of any
       stream cipher; various other papers use~\cite{MASCAB:LeaZenHaw:09} or
       extended~\cite{MASCAB:BHNS:10} it.
  }
}

@inproceedings{MASCAB:TSSSM:03,
  keywords     = KEYWORDS,
  author       = {Y. Tsunoo and T. Saito and T. Suzaki and M. Shigeri and H. Miyauchi},
  title        = {Cryptanalysis of {DES} Implemented on Computers with Cache},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 2779}, 
  pages        = {62--76}, 
  year         = {2003},
  addendum     = {
    This is a seminal paper, in that it represents one of the first concrete
    cache-based timing attack on a cryptographic primitive, namely optimised
    DES (i.e., with wide look-up tables that include the permutations).  The
    paper uses a $1$-round toy example (in Figure $1$) to explain the attack
    strategy (Section $2$), which includes
    1) an acquisition phase, using either the
       a) non-elimination (or constructive) approach that uses evidence of
          many cache hits   to infer   equality (upto cache line granularity)
          of two S-box indices,
       a)     elimination (or constructive) approach that uses evidence of
          many cache misses to infer inequality (upto cache line granularity)
          of two S-box indices,
       then
    2) a cryptanalytic post-processing phase, that uses the key difference 
       produced by the acquisition phase to guide a constrained brute-force
       search and thus perform key recovery.
    This is then extended to full DES (Section $3$); the experiment reported
    assumes a cold L1 cache (which is flushed before every DES invocation),
    and uses the x86 {\tt rdtsc} to measure execution time inline with said
    invocation (vs. with a separate attack and target process).
  }
}

@inproceedings{MASCAB:TTMM:02,
  keywords     = KEYWORDS,
  author       = {Y. Tsunoo and E. Tsujihara and K. Minematsu and H. Miyauchi},
  title        = {Cryptanalysis of Block Ciphers Implemented on Computers with Cache},
  booktitle    = {International Symposium on Information Theory and Its Applications (ISITA)}, 
  pages        = {803--806},
  year         = {2002},
  addendum     = {
    Although the title does not suggest it, this paper presents an attack on
    the MISTY block cipher.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=neg,style=dcache/trace}}

@inproceedings{MASCAB:AciKoc:06,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and \c{C}.K. Ko\c{c}},
  title        = {Trace-Driven Cache Attacks on {AES}},
  booktitle    = {Information and Communications Security (ICS)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 4307},   
  pages        = {112--121},
  year         = {2006}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=neg,style=dcache/power}}

@inproceedings{MASCAB:MorHin:15,
  keywords     = KEYWORDS,
  author       = {A. Moradi and G. Hinterw\"{a}lder},
  title        = {Side-Channel Security Analysis of Ultra-Low-Power {FRAM}-Based {MCUs}},
  booktitle    = {Constructive Side-Channel Analysis and Secure Design (COSADE)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9064},
  pages        = {239--254},
  addendum     = {
    Versus~\cite{MASCAB:BZBMP:05}, for instance, where the power consumption
    of a cache is {\em simulated}, this paper presents some concrete results
    for AES executed on a low-power micro-controller: Figure $5$ provides a
    clear illustration of how cache hits and misses can be distinguished in 
    a trace of power consumption, a fact then leveraged in a trace-driven
    attack.
  }
}

@inproceedings{MASCAB:FouTun:06,
  keywords     = KEYWORDS,
  author       = {J.J.A. Fournier and M. Tunstall},
  title        = {Cache Based Power Analysis Attacks on {AES}},
  booktitle    = {Australasian Conference on Information Security and Privacy (ACISP)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 4058},
  pages        = {17--28},
  year         = {2006},
  addendum     = {
    This paper presents two (theoretical): there is no experimental data for
    either) attacks on AES, based on the assumption that the attacker could
    monitor power consumption and hence cache behaviour of a target.  The
    attacks target
    1) look-ups to the pre-computed S-box within {\tt SubBytes},
       and
    2) look-ups to the pre-computed {\tt xtime} within {\tt MixColumns}.
    Both could be characterised as trace-driven, and stem from the attacker
    searching specific plaintext bytes: when a cache hit is observed, they
    can form a relationship between known and unknown variables (i.e., the
    plaintext and key material), and thus allow subsequent cryptanalysis.
  }
}

@inproceedings{MASCAB:BZBMP:05,
  keywords     = KEYWORDS,
  author       = {G. Bertoni and V. Zaccaria and L. Breveglieri and M. Monchiero and G. Palermo},
  title        = {{AES} power attack based on induced cache miss and countermeasure},
  booktitle    = {Information Technology: Coding and Computing (ITCC)},
  pages        = {586--591},
  year         = {2005},
  addendum     = {
    This paper mounts a (sort of) trace-driven cache attack on AES: the power
    consumption of a target device is used to distinguish between cache hits 
    and misses, yielding said trace.  That said, the strategy, namely
    1) execute AES to prime the cache with S-box content,
    2) read $i$-th element of an array whose base address mirrors the S-box,
       thus evicting the $i$-th S-box entry,
    3) (re)execute AES, and infer use of S-box element $i$ iff. a cache miss
       is observed,
    has a distinctly access-driven flavour: the attack model assumes a user
    mode attacker, and kernel mode cryptographic service as the target.  The
    attack is validated using simulation (via the MIPS-based SimpleScalar
    framework).
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=neg,style=icache}}

@inproceedings{MASCAB:AciBruGra:10,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and B. Brumley and P. Grabher},
  title        = {New Results on Instruction Cache Attacks},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 6225}, 
  pages        = {110--124}, 
  year         = {2010}
}

@inproceedings{MASCAB:AciSch:08,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and W. Schindler},
  title        = {A Vulnerability in {RSA} Implementations Due to Instruction Cache Analysis and Its Demonstration on {OpenSSL}},
  booktitle    = {Topics in Cryptology (CT-RSA)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 4964}, 
  pages        = {256--273}, 
  year         = {2008}
}

@inproceedings{MASCAB:Aciicmez:07:b,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez},
  title        = {Yet Another MicroArchitectural Attack: Exploiting {I}-cache},
  booktitle    = {ACM Workshop on Computer Security Architecture},
  pages        = {11--18},
  year         = {2007}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=pos/hardware}}

@inproceedings{MASCAB:KKEEAPJ:17,
  keywords     = KEYWORDS,
  author       = {M. Kayaalp and K.N. Khasawneh and H. Esfeden and J. Elwell and N. Abu-Ghazaleh and D. Ponomarev and A. Jaleel},
  title        = {{RIC}: Relaxed Inclusion Caches for Mitigating {LLC} Side-Channel Attacks},
  booktitle    = {Design Automation Conference (DAC)}, 
  pages        = {7:1--7:6},
  year         = {2017},
  addendum     = {
    This paper presents RIC, a design concept to secure LLCs vs. cache-based
    side-channel attack.  The idea is to (selectively) relax the inclusivity
    property of (e.g., x86-based) LLC designs; this is achieved by adding a
    per line flag to enable RIC, which is controlled to allow
    a) read-only    (e.g., S-box tables, or instructions)
       or
    b) thread-local (e.g., any pre-computation for windowed exponentiation)
    to avoid eviction due to inclusivity.  As such, RIC aims to prevent any
    attack strategy (e.g., {\sc Flush+Reload}) that depends on inclusivity;
    it does so without disadvantages, such as degraded performance, that may
    be levelled at alternatives such as partitioning.
  }
}

@inproceedings{MASCAB:FucLee:15,
  keywords     = KEYWORDS,
  author       = {A. Fuchs and R.B. Lee},
  title        = {Disruptive Prefetching: Impact on Side-channel Attacks and Cache Designs},
  booktitle    = {ACM International Systems and Storage Conference (SYSTOR)},
  pages        = {14:1--14:12},
  year         = {2015},
  addendum     = {
    The central idea in this paper is to harness hardware pre-fetchers as a
    countermeasure against cache-based side-channel attacks: various papers
    note the negative influence pre-fetching can have on attack success (by 
    polluting the cache state vs. that expected, for example), so this idea 
    attempts to intentionally maximise said influence in a sense.  

    Alterations to two different pre-fetching algorithms are investigated,
    namely
    1) the approach in Section $3.2$ randomises the length and order of 
       accesses in the pre-fetched address stream, attempting to balance
       the degree of randomisation with resulting performance,
    2) the approach in Section $3.3$ alters the selection of cache set, so
       as to achieve a uniform set access pattern.
    Section $4$ demonstrates that a combination of 1) and 2) act to prevent
    a (simulated) {\sc Prime+Probe}-based attack.
  }
} 

@article{MASCAB:KASK:08,
  keywords     = KEYWORDS,
  author       = {G. Keramidas and A. Antonopoulos and D. N. Serpanos and S. Kaxiras},
  title        = {Non deterministic caches: A simple and effective defense against side channel attacks},
  booktitle    = {Design Automation for Embedded Systems}, 
  publisher    = {Springer-Verlag},
  volume       = {12},
  number       = {3}, 
  pages        = {221--230}, 
  year         = {2008},
  addendum     = {
    This paper repurposes an existing idea, namely cache decay (or, simply,
    timed cache line invalidation), as a countermeasure against cache-based
    side-channel attack; originally designed as a mechanism to reduce power
    consumption, a per line counter disables (and so invalidates) said line 
    once a period of inactivity (the decay interval) passes.  The proposal
    is to reset the counters with a random value, which induces a level of
    non-deterministic behaviour due to randomisation of the decay interval
    and hence triggered invalidation.  This noise wrt. cache behaviour acts
    to degrade the validity of inferences based on a given acquisition (e.g., 
    that longer execution time implies more cache misses {\em solely} due to 
    algorithmic behaviour).
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=pos/software}}

@inproceedings{MASCAB:GSOHLC:17,
  keywords     = KEYWORDS,
  author       = {D. Gruss and F. Schuster and O. Ohrimenko and I. Haller and J. Lettner and M. Costa},
  title        = {Strong and Efficient Cache Side-Channel Protection using Hardware Transactional Memory},
  booktitle    = {Computer and Communications Security (CCS)},
  pages        = {217--233},
  year         = {2017},
  addendum     = {
    Within the context of access-driven cache attacks,
    this paper presents a  countermeasure technique which harnesses the Intel 
    transactional memory, or TSX feature; 
    the technique is dubbed {\sc Cloak}.
    The basic idea is to execute the target functionality within a TSX-based
    transaction: by first warming the cache with the data required, doing so
    means any deliberate manipulation (e.g., eviction) by an attack process
    will abort the transaction and hence foil the attack.  Conceptually, the
    approach is similar to AESSE~\cite{MASCAB:MulDewFre:10} (and/or similar)
    which mitigate cold-boot attacks by maintaining a working set of data in
    the register file; here, the working set is instead maintained in a (or 
    the) cache, and eviction is detected (vs. avoided) via the transaction
    abort.

    Some care is required (e.g., wrt. correct warming) to apply {\sc Cloak},
    but doing so is reality non-invasive: the transaction can be applied to
    ``wrap'' target functionality, at a higher level than the functionality
    itself for example.  Section $6$ highlights this fact by retrofitting
    and evaluating {\sc Cloak} using previously vulnerable functionality.
  }
}

@inproceedings{MASCAB:ZouReiZan:16,
  keywords     = KEYWORDS,
  author       = {Z. Zhou and M.K. Reiter and Y. Zhang},
  title        = {A software approach to defeating side channels in last-level caches},
  booktitle    = {Computer and Communications Security (CCS)},
  pages        = {871--882},
  year         = {2016},
  addendum     = {
    The paper presents {\sc CacheBar}, a software-only countermeasure against
    LLC-based attacks: it basically implements security-aware page management.
    To prevent {\sc Flush+Reload} attacks it implements a copy-on-{\em access}
    policy to (just-in-time) disallow sharing of pages (which enable such an
    attack strategy); there is an option to reshare (or deduplicate) pages if
    access to them is temporally non-local (i.e., non-indicative of attack).
    To prevent {\sc Prime+Probe} attacks it implements a mechanism to limit
    the number of lines per set an attacker can access: this places a limit
    on the ability to observe activity in the set.
  }
}

@inproceedings{MASCAB:LGYMRHL:16,
  keywords     = KEYWORDS,
  author       = {F. Liu and Q. Ge and Y. Yarom and F. Mckeen and C. Rozas and G. Heiser and R.B. Lee},
  title        = {{CATalyst}: Defeating last-level cache side channel attacks in cloud computing},
  booktitle    = {High Performance Computer Architecture (HPCA)},
  pages        = {406--418},
  year         = {2016},
  addendum     = {
    This paper presents {\sc CATalyst}, a software system that harnesses the
    so-called Cache Allocation Technology (CAT) as a countermeasure against
    LLC-based attack.  Intel market CAT as a performance-oriented technology
    that protects selected LLC content from eviction: some number of Classes 
    of Service (COS) are identified and used to tagged content, which cannot 
    then be evicted by a different COS.  In practice, this means any content 
    in the LLC wrt. some performance-critical web-server, for example, could
    be protected against eviction by other, non-critical processes.  
    
    CATalyst essentially re-purposes the CAT hardware mechanism, using it as 
    a security-oriented technology.  Focusing on cross-VM attacks using the
    LLC, it offers access to a set of secure pages that are ``pinned'' (or 
    locked) in a managed cache partition (as supported by CAT).  Such pages
    are is protected wrt. contention, meaning a security-critical COS can be
    protected against access-driven cache attacks (e.g., {\sc Flush+Reload}) 
    that interrogate the residency of content by timing (controlled) eviction.
  }
}

@inproceedings{MASCAB:ZhaRei:13,
  keywords     = KEYWORDS,
  author       = {Y. Zhang and M. K. Reiter},
  title        = {D\"{u}ppel: retrofitting commodity operating systems to mitigate cache side channels in the cloud},
  booktitle    = {Computer and Communications Security (CCS)},
  pages        = {827--838},
  year         = {2013},
  addendum     = {
    This paper presents {\sc D\"{u}ppel}, which automatically flushes content
    security-critical content from the cache; the mechanism focuses on L1 and 
    L2 caches, vs. LLC for example, and realised within the kernel.  The idea
    of cache flushing as a countermeasure against attack is not new: doing so
    during a context switch means content relating to some target process is
    always evicted before an attacker executes, and therefore no information 
    can be leaked by the former to the latter via the cache.  

    However, the overhead of flushing is significant; this suggests value in 
    a more ``intelligent'' policy for doing so, which {\sc D\"{u}ppel} offers.  
    More specifically, it
    a) controls the frequency of flushes st. they can be avoided if there is
       no chance of leakage anyway,
    b) allows processes to be marked as security-critical (using an entry in
       the file system to communicate between user- and kernel-space), which 
       then acts as a hint as to whether a flush is required or not.
  }
}

@article{MASCAB:Gueron:12,
  keywords     = KEYWORDS,
  author       = {S. Gueron},
  title        = {Efficient software implementations of modular exponentiation},
  journal      = {Journal of Cryptographic Engineering},
  publisher    = {Springer-Verlag},
  volume       = {2},
  number       = {1},
  pages        = {31--43},
  year         = {2012},
  addendum     = {
    See Section $7$  re. scatter-gather technique for layout of pre-computed
    values in modular exponentiation (cf. RSA).
  }
}

@inproceedings{MASCAB:GGOFWD:09,
  keywords     = KEYWORDS,
  author       = {V. Gopal and J. Guilford and E. Ozturk and W. Feghali and G. Wolrich and M. Dixon},
  title        = {Fast and constant-time implementation of modular exponentiation},
  booktitle    = {Reliable Distributed Systems},
  year         = {2009},
  url          = {http://www.cse.buffalo.edu/srds2009/escs2009_submission_Gopal.pdf},
  addendum     = {
    See Section $IV$ re. scatter-gather technique for layout of pre-computed
    values in modular exponentiation (cf. RSA).
  }
}

@inproceedings{MASCAB:BanRiz:08,
  keywords     = KEYWORDS,
  author       = {J. Bani and S.S. Rizvi},
  title        = {Minimizing Cache Timing Attack Using {D}ynamic {C}ache {F}lushing ({DCF}) Algorithm},
  booktitle    = {Wireless Telecommunications Symposium (WTS)},
  pages        = {399--404},
  year         = {2008},
  addendum     = {
    As outlined in Figure $10$ the main proposal in the paper is the idea of
    randomly flushing the cache, which a) introduces temporal jitter to some
    extent, but also b) disrupts any attempt to correlate execution time or
    cache state with key material (i.e., an attack).
  }
}

@techreport{MASCAB:ErlAba:07,
  keywords     = KEYWORDS,
  author       = {\'{U}. Erlingsson and M. Abadi},
  title        = {Operating system protection against side-channel attacks that exploit memory latency},
  institution  = {Microsoft},
  number       = {MSR-TR-2007-117},
  year         = {2007},
  url          = {http://www.microsoft.com/en-us/research/publication/operating-system-protection-against-side-channel-attacks-that-exploit-memory-latency},
  addendum     = {
    This paper considers countermeasures against cache-based attack, under the
    general assumption that processes will explicitly request (via an API akin
    to {\tt malloc}) and then use a protected ``stealth'' region of memory.  A
    set of schemes to manage such regions, thereby (supposedly) preventing an
    attack: these are
    1) partition the region, st. {\em only} addresses from the stealth region
       can be resident in a given cache line and/or set,
    2) enforce a cache flush when context switching a process that has used
       a stealth region (st. there may be security-critical content resident
       in the cache),
    3) pre-load (or ``warm'') the cache with content from the stealth region
       when context switching.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=pos/analysis}}

@inproceedings{MASCAB:ManWebKoe:17,
  keywords     = KEYWORDS,
  author       = {H. Mantel and A. Weber and B. K\"{o}epf},
  title        = {A Systematic Study of Cache Side Channels across {AES} Implementations},
  booktitle    = {Engineering Secure Software and Systems (ESSoS)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 10379},
  pages        = {213--230},
  year         = {2017},
  addendum     = {
    Having extended the {\sc CacheAudit} tool of~\cite{MASCAB:DFKMR:13} to
    cope with a larger set of x86 instructions, the main goal of the paper
    is a systematic evaluation of leakage from deployed AES implementations
    (wrt. cache-based attacks); it considers LibTomCrypt, mbed TLS, Nettle,
    and OpenSSL.  Various conclusions are presented, with perhaps the most
    interesting being the interaction with look-up table geometry (e.g.,
    their number, element type, and memory footprint) and security.

    As an aside, a number of nicely organised micro-surveys are included, 
    such as
    a) Section $3.1$ on static analysis techniques for leakage assessment,
       and
    b) Section $6$ on related work, especially lineage of countermeasures.
  }
}

@inproceedings{MASCAB:DFKMR:13,
  keywords     = KEYWORDS,
  author       = {G. Doychev and D. Feld and B. K\"{o}pf and L. Mauborgne and J. Reineke},
  title        = {{CacheAudit}: A Tool for the Static Analysis of Cache Side Channels},
  booktitle    = {USENIX Security Symposium},
  pages        = {431--446},
  year         = {2013},
  addendum     = {
    This paper presents a (theoretical) model that allows analysis of the
    cache-related behaviour of target and attack processes, and then also
    implements and evaluates a (concrete) tool based on this; the tool is
    able to accept x86 binaries as input, and provide guarantees wrt. the
    leakage possible and hence viability of an attack.  The tool itself,
    termed {\sc CacheAudit}, employs static analysis based on the use of
    abstract interpretation (of the binary).
    Evaluation with AES (per PolarSSL) and Salsa20 allows several general
    conclusions (e.g., that pre-loading can reduce leakage, or that larger 
    line size can reduce leakage); perhaps the strongest claim is that 
    (the implementation of) Salsa20 provably avoids all attacks (wrt. the 
    model at least).

    Interestingly, Section $3.4$ seems to model an access-driven attacker 
    that is able to interrogate the cache state {\em on termination} of
    the target process: it is only able to observe the {\em final} cache
    state.  This model does not seem to match state-of-the-art strategies
    for attack, such as {\sc Flush+Reload}, which are more continuous in
    nature (i.e., could recover each $c_i$, not just $c_n$).
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=alt}}

@inproceedings{MASCAB:GES:17,
  keywords     = KEYWORDS,
  author       = {B. Gulmezoglu and T. Eisenbarth and B. Sunar},
  title        = {Cache-Based Application Detection in the Cloud Using Machine Learning},
  booktitle    = {ACM Symposium on Information, Computer and Communications Security (AsiaCCS)},
  pages        = {288--300},
  year         = {2017},
  addendum     = {
    This paper could be viewed as a progression from~\cite{MASCAB:IIES:15},
    in that the goal is generalised: rather than specifically detecting use
    of cryptographic libraries, it aims to detect use of given applications
    in general.  The idea is similar to~\cite{MASCAB:GruSprMan:15} in the
    sense that profiles of behaviour, wrt. the cache, are captured for each
    application; rather than comparison with a template, however, machine
    learning, specifically Support Vector Machines (SVMs), is used as a 
    classifier.
  }
} 

@article{MASCAB:IIES:15,
  keywords     = KEYWORDS,
  author       = {G. Irazoqui and M.S. Inci and T. Eisenbarth and B. Sunar},
  title        = {Know Thy Neighbor: Crypto Library Detection in the Cloud},
  journal      = {Proceedings on Privacy Enhancing Technologies (PoPETs)},
  issue        = {1},
  pages        = {25--40},
  year         = {2015},
  addendum     = {
    This paper presents a novel use of cache-based side-channel: rather than
    mount an attack per se, the idea is to {\em identify} an attack target.
    The goal is to determine whether or not another, co-located target VM is
    using given cryptographic library (e.g., OpenSSL vs. GnuTLS) of a given 
    version (e.g., 0.9.8k vs. 1.0.0a).  This, coupled with another approach 
    that supports recovery of the IP address used by the target VM, equips
    the attacker with information they can then use to subsequently launch
    a tailored attack (e.g., Heartbleed, based on identifying a vulnerable
    version of OpenSSL).

    The technique to achieve this is actually fairly simple: the idea is to
    capitalise on memory deduplication, so using a {\sc Prime+Probe} attack 
    strategy (wrt. LLC) to detect the difference in access time for 
    a)     deduplicated (i.e., library is     used) 
       and 
    b) non-deduplicated (i.e., library is not used) 
    pages.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=analysis/hw}}

@article{MASCAB:GRZIHE:17,
  keywords     = KEYWORDS,
  author       = {M. Green and L. Rodrigues-Lima and A. Zankl and G. Irazoqui and J. Heyszl and T. Eisenbarth},
  title        = {{\tt AutoLock}: Why Cache Attacks on ARM Are Harder Than You Think},
  journal      = {CoRR},
  volume       = {abs/1703.09763},
  year         = {2017},
  url          = {http://arxiv.org/abs/1703.09763},
  addendum     = {
    This paper (see also~\cite{MASCAB:Green:17}) outlines a subtle discovery
    wrt. access-driven, cache-based attacks on ARM-based targets: though not
    documented by processor datasheets, a patent~\cite{MASCAB:Williamson:12}
    describes a performance-enhancing feature that turns out to complicates 
    the challenge of inter-core eviction (a necessary step in some attacks). 
    The feature relates to inclusivity, i.e., the property that all content
    resident in level $i$ must also be resident in level $j<i$ (content that
    is resident in the L1 cache, for example, must be resident in the LLC):
    it prevents eviction from level $j$ if the content is also resident in
    level $i$, preventing the performance penalty associated with eviction
    from level $i$.  The paper terms this {\tt AutoLock}, in the sense that
    the content is automatically locked into level $j$ based on this rule.

    The presence of {\tt AutoLock} makes controlled eviction of content in
    lower-level caches, particularly an LLC that enables inter-core attacks,
    problematic; Section $2$ notes that the effect is similar to targeting
    a non-inclusive (i.e., exclusive) cache hierarchy.  As such, the paper
    1) introduces three approaches to verify whether or not {\tt AutoLock} 
       is present on a given platform,
    2) an analysis of when and how {\tt AutoLock} impacts on existing attack
       strategies (cf. Table $4$),
    3) a range of circumvention techniques, that allow existing attacks to
       succeed even if {\tt AutoLock} is present.
  }
}

@article{MASCAB:GeYarHei:16,
  keywords     = KEYWORDS,
  author       = {Q. Ge and Y. Yarom and G. Heiser},
  title        = {Do hardware cache flushing operations actually meet our expectations?},
  journal      = {CoRR},
  volume       = {abs/1612.04474},
  year         = {2016},
  url          = {http://arxiv.org/abs/1612.04474},
  addendum     = {
    Provided the execution of target and attack processes do not overlap, a
    clean countermeasure is to flush all micro-architectural state during a
    context switch: if the (new) dispatched process begins execution using
    no state associated with the (old) descheduled process, there can be no
    leakage between the two.  This paper examines such an approach, thereby
    offering an analysis of how effective if can be given support available
    in an underlying platform (ARM and x86 specifically); although the title 
    does not suggest it, the paper examines data and instruction caches plus
    other cache-like structures such as the branch target buffer.  

    The results are fairly pessimistic, in the sense
    a) micro-architectural resources exist that cannot be directly flushed
       (e.g., ARM and x86 prefetchers) because there is no support in the
       ISA to do so,
    b) where said resources {\em can} be directly flushed, doing so can be
       complicated by the form of support in the ISA,
       and
    c) even when the resources {\em are} flushed, bandwidth-based channel
       evaluation {\em still} suggests strong leakage: this implies there
       is some deficiency in the flushing mechanism, and/or {\em another}
       mechanism that still leaks similar information.
    One central conclusion is that platform vendors {\em at least} need to
    provide more transparency for, and, ideally, better mechanisms in order
    to support robust countermeasures.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=analysis/attack}}

@techreport{MASCAB:CanLauSez:06,
  keywords     = KEYWORDS,
  author       = {A. Canteaut and C. Lauradoux and A. Seznec},
  title        = {Understanding cache attacks},
  institution  = {Institut National de Recherche en Informatique et en Automatique (INRIA)},
  number       = {RR-5881},
  year         = {2006}
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/cache,topic=misc}}

@inproceedings{MASCAB:WanLee:06,
  keywords     = KEYWORDS,
  author       = {Z. Wang and R.B. Lee},
  title        = {Covert and Side Channels Due to Processor Architecture},
  booktitle    = {Annual Computer Security Applications Conference (ACSAC)},
  pages        = {473--482},
  year         = {2006},
  addendum     = {
    In a short space, this paper includes quite a few contributions: it
    1) introduces a source of micro-architectural leakage, namely the fact
       contention exists between hardware threads (executing on an SMT-based 
       core) wrt. the limited number of shared functional units (e.g., the
       integer multiplier, which would be used by an RSA implementation, for
       example),
    2) introduces a source of micro-architectural leakage, namely the fact
       that certain forms of speculative execution (per IA-64, or Itanium)
       can be used to probe the state of a cache, for example,
    3) proposes the concept of selective partitioning (of shared resources;
       the idea is to selectively make them not shared) as a countermeasure 
       against associated attacks, 
       and
    4) proposes the RPCache design: the central idea is to specify (using a 
       dedicated register) a per-set permutation, which is basically used to 
       randomise the mapping between address and set; the privilege level one
       requires to access the register, plus the randomising effect, both act 
       to complicate attacks (e.g., due to additional noise, cf. ARM random 
       replacement policy).
  }
}

% =============================================================================
@STRING{KEYWORDS={class=channel/side/branch,topic=neg}}

@article{MASCAB:LSGKKP:16,
  keywords     = KEYWORDS,
  author       = {S. Lee and M.-W. Shih and P. Gera and T. Kim and H. Kim and M. Peinado},
  title        = {Inferring Fine-grained Control Flow Inside {SGX} Enclaves with Branch Shadowing},
  journal      = {CoRR},
  volume       = {abs/1611.06952},
  year         = {2016},
  url          = {http://arxiv.org/abs/1611.06952},
  addendum     = {
    This paper presents a mechanism for fine-grained analysis of branch
    behaviour, of a target enclave by some attacker.  The mechanism is
    similar to~\cite{MASCAB:EvtPonAbu:16}, in so far as it relies on use
    of so-called shadow branches overlaid with the target branches st.
    they contend in various branch prediction structures (e.g., the BTB,
    which is basically a cache for branch target addresses).  Associated 
    variation in execution time can be leveraged to recover the branch
    behaviour (e.g., branch un/taken status, or branch target address).
    Rather than a TSC-based approach to destinguish rollback (or not, so
    longer or shorter execution time), the Last Branch Record (LBR) of
    Intel processors is used: this is akin to a performance counter for 
    branches, logging information wrt. recent, taken branches for later 
    analysis.
    Overall, the paper
    1) details the construction of how shadow branches,
    2) exploits this within various concrete attacks (in Section $4$),
       including a conditional subtraction included in the mbed TLS 
       implementation of Montgomery multiplication; 
    3) considers various countermeasures against the mechanism, which
       include a flush-based approach (predicated on hardware support, 
       cf.~\cite{MASCAB:GeYarHei:16}), and a software-based approach 
       termed {\sc Zigzagger}; the latter realises all branches via a
       form of dispatch, imposes a performance overhead at run-time,
       but could be automated (by the compiler) at compile-time.
  }
}

% =============================================================================
@STRING{KEYWORDS={class=channel/side/arith,topic=neg}}

@inproceedings{MASCAB:KPVV:16,
  keywords     = KEYWORDS,
  author       = {T. Kaufmann and H. Pelletier and S. Vaudenay and K. Villegas},
  title        = {When Constant-Time Source Yields Variable-Time Binary: Exploiting {Curve25519-donna} Built with {MSVC}}, 
  booktitle    = {Cryptology and Network Security (CANS)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 10052},
  pages        = {573--582},
  year         = {2016},
  addendum     = {
    The paper does not {\em use} a micro-architectural resource per se,
    but {\em relates} to (micro-)architecture in a general sense.  It 
    describes an attack on an implementation\footnote{
      \url{http://github.com/agl/curve25519-donna}
    } of the X25519 standard for Curve25519 (as used for ECDH) which
    follows RFC 7748.  The implementation should be constant-time, but
    in a specific setting is not: on $64$-bit platforms, the $32$-bit 
    MSVC compiler uses a run-time library ({\tt llmul.asm}) to perform
    $64 \times 64$-bit multiplications and this library is {\em not}
    constant-time (it include a short-cut branch to deal efficiently
    with ``short'' inputs whose $32$ MSBs are zero).  This fact is 
    exploited to recover the (secret) scalar multiplier by observing
    the execution time of (quite a lot of) scalar multiplications.

    Some of the statements, or at least terminology used in the paper 
    have been a matter of debate; one way to interpret the discussion
    is as a question wrt. where the cause stems from, e.g., from the 
    RFC, the implementation, the compiler, the (micro-)architecture.
    Specifically, the paper states that the implementation 
    ``follows RFC 7748 requirements''; 
    this was critiqued by Bernstein\footnote{
      See \url{http://twitter.com/hashbreaker/status/821067916330303488}.
    } who quoted the RFC as noting it remains
    ``important that the arithmetic used not leak information about the integers''
    and thus suggesting the implementation is actually non-compliant.
  }
}

@inproceedings{MASCAB:AKMJLS:15,
  keywords     = KEYWORDS,
  author       = {M. Andrysco and D. Kohlbrenner and K. Mowery and R. Jhala and S. Lerner and H. Shacham},
  title        = {On Subnormal Floating Point and Abnormal Timing},
  booktitle    = {IEEE Symposium on Security \& Privicy (S\&P)},
  pages        = {623--639},
  year         = {2015},
  addendum     = {
    IEEE floating point uses a normalised representation; the mantissa will
    be scaled st. a binary point appears after the most-significant $1$ bit,
    then represented without said bit (which is then implicit).  A class of
    subnormal (or denormal) representations relaxes this, however, avoiding 
    normalisation st. the implicit bit is $0$.  The values represented can
    be closer to zero as a result.  This paper targets said special-case,
    1) noting that arithmetic using them subnormal representations results
       in (much) longer latency,
    2) harnessing the resulting data-dependent execution time to mount a
       side-channel attack on Firefox (under the pixel stealing model: the
       idea that an attacker web-page recovers information from a target
       web-page that should be isolated),
       and
    3) outlining a (carefully designed) countermeasure, namely the library
       libfixedtimefixedpoint, that ``patches'' floating point operations
       with constant-time, fixed point analogues.
  }
}

@inproceedings{MASCAB:GEPT:09,
  keywords     = KEYWORDS,
  author       = {J. Gro{\ss}sch\"{a}dl and E. Oswald and D. Page and M. Tunstall},
  title        = {Side-Channel Analysis of Cryptographic Software via Early-Terminating Multiplications},
  booktitle    = {Information, Security and Cryptology (ICISC)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 5984},
  pages        = {176--192},
  year         = {2009},
  addendum     = {
    \cite{MASCAB:SchWhi:98} explains that data-dependent execution time can 
    stem from multiplier hardware that supports early-termination.  This is
    an optimisation where using a multiplier (vs. multiplicand) operand of 
    a certain form implies lower latency than in general (i.e., when using 
    a random multiplier operand).  The ARM7TMI includes such hardware, st.
    a multiplier operand with more contiguous MSBs equal to zero will imply
    lower latency (ranging between $2$ and $5$ clock cycles overall).  This
    paper looks at this concrete platform, and
    1) presents evidence the early-termination behaviour can be observed in
       a trace of power consumption (cf. Figure $1$),
    2) mounts a range of attacks on cryptographic primitives based on this
       fact (see Section $3$),
       and
    3) presents a countermeasure (see Section $4$) that ``patches'' each
       multiplication instruction with a longer instruction sequence which
       is constant-time irrespective of the multiplier operand.
  }
}

@inproceedings{MASCAB:AciSei:07,
  keywords     = KEYWORDS,
  author       = {O. Ac\i{}i\c{c}mez and J.-P. Seifert},
  title        = {Cheap Hardware Parallelism Implies Cheap Security},
  booktitle    = {Fault Diagnosis and Tolerance in Cryptography (FDTC)},
  pages        = {80--91},
  year         = {2007},
  addendum     = {
    To manage the issue of scale, SMT-based processor cores multiplex some 
    (smaller) number of functional (or execution) units between a (larger)
    number of hardware-supported threads executed in quasi-parallel; when 
    a complementary instruction mix results (e.g., from composition of one 
    compute-bound and one memory-bound thread), there is little contention.
    This paper notices the execution units are a shared micro-architectural,
    albeit one that does not retain state (cf. a cache), and, based on this
    fact, mounts an attack on RSA as implemented in OpenSSL: the basic idea
    is that if an attack process saturates the multiplier, timing execution
    of issued multiplication instructions, it will notice variation iff. a
    target process attempts concurrent use of the multiplier.  Modulo some
    issues such as synchronisation and noise inherent in similar strategies
    for cache-based attack, this allows the attacker to recover bits of the
    exponent by distinguishing between multi-precision square and multiply 
    operations (which perform different limb-wise multiplications, and so
    make differing use of the associated execution unit).  As an aside, the 
    paper also gives some evidence that a longer exponent makes the attack
    easier (see also~\cite{MASCAB:Walter:03}).
  }
}

@inproceedings{MASCAB:WalSam:05,
  keywords     = KEYWORDS,
  author       = {C.D. Walter and D. Samyde},
  title        = {Data dependent power use in multipliers},
  booktitle    = {IEEE Symposium on Computer Arithmetic (ARITH)}, 
  pages        = {4--12}, 
  year         = {2005},
  addendum     = {
    Depending on the precise definition, this paper could be deemed  at the 
    periphery of micro-architectural attacks: it focuses on the switching 
    activity of multipliers, and so aligns more with general power analysis 
    (e.g., DPA) attacks.  However, in doing so it formulates a model so as
    to assess a variety of multiplier designs (which could be deemed part 
    of a micro-architecture).
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/arith,topic=pos/hardware}}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/arith,topic=pos/software}}

@unpublished{MASCAB:BenHamouda:11,
  keywords     = KEYWORDS,
  author       = {F. Ben Hamouda},
  title        = {Exploration of efficiency and side-channel security of different implementations of {RSA}},
  year         = {2011},
  url          = {http://www.normalesup.org/~fbenhamo/files/stage2011/report.pdf},
  addendum     = {
    Figure $E.1$ gives a more efficient, constant-time instruction sequence 
    for multiplication (vs.~\cite{MASCAB:GEPT:09}) on the ARM7TDMI (or some
    equivalent with a similar early-terminating multiplier). 
  }
}

% =============================================================================
@STRING{KEYWORDS={class=channel/side/noc,topic=pos}}

@inproceedings{MASCAB:ZWMW:17,
  keywords     = KEYWORDS,
  author       = {Y. Zhou and S. Wagh and P. Mittal and D. Wentzlaff},
  title        = {Camouflage: Memory Traffic Shaping to Mitigate Timing Attacks},
  booktitle    = {High-Performance Computer Architecture (HPCA)},
  pages        = {337--348},
  year         = {2017},
  addendum     = {
    The basic idea of this paper is to address the issue of timing attacks
    on the (system) memory bus; for example, this remit excludes 
    a) probing of the bus wrt. data (vs. timing of accesses to it),
       and
    b) timing attacks on intra-core elements of the memory hierarchy (e.g.,
       caches) that can satisfy accesses {\em before} they are delegated to
       components attached to the bus (e.g., DRAM, per Figure $5$).
    It does so by proposing a hardware-based mechanism to ``shape'' (i.e.,
    manipulate) traffic on the bus so it fits a pre-selected distribution
    wrt. timing characteristics; it does so without reverting to existing,
    unattractive policies such as temporal partitioning (aka. time slicing)
    or fixed service (i.e., forcing uniform access timing and pattern).
  }
}

% =============================================================================
@STRING{KEYWORDS={class=channel/side/misc,topic=neg}}

@inproceedings{MASCAB:JiaFeiKae:17,
  keywords     = KEYWORDS,
  author       = {Z.H. Jiang and Y. Fei and D. Kaeli},
  title        = {A Novel Side-Channel Timing Attack on {GPUs}},
  booktitle    = {Great Lakes Symposium on VLSI (GLSVLSI)},
  pages        = {167--172},
  year         = {2017},
  addendum     = {
    Somewhat similarly to \cite{MASCAB:Fomin:16}, this paper harnesses bank 
    conflicts (causing data-dependent execution time) in the shared memory 
    of an Nvidia-based GPU to mount a time-based side-channel attack on AES.
  }
} 

@article{MASCAB:Fomin:16,
  keywords     = KEYWORDS,
  author       = {D.B. Fomin},
  title        = {A timing attack on {CUDA} implementations of an {AES}-type block cipher},
  journal      = {Matematicheskie Voprosy Kriptografii},
  volume       = {7},
  issue        = {2},
  pages        = {121--130},
  year         = {2016},
  addendum     = {
    This paper presents timing attack on AES: there are two distinguishing
    points vs. related work, namely
    1) a GPU- rather than CPU-based platform is targeted; specifically, a
       CUDA-based implementation is executed on a NVIDIA-based platform,
       and
    2) address-dependent variation in execution time that stems from bank
       conflicts in the (shared) memory is harnessed; this contrasts, for
       example, with a traditional, cache-based attack.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/misc,topic=pos/hardware}}

@inproceedings{MASCAB:ZonYen:16,
  keywords     = KEYWORDS,
  author       = {A.D. Zonenberg and B. Yener},
  title        = {{Antikernel}: A Decentralized Secure Hardware-Software Operating System Architecture},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9813}, 
  pages        = {237-256}, 
  year         = {2016},
  addendum     = {
    This paper presents a kernel design paradigm (the antikernel), wherein
    traditional kernel responsibilities are distributed and hence isolated: 
    all interaction between kernel sub-systems is via message passing.  To
    support this, it introduces a hardware implementation (named SARATOGA)
    with a MIPS-based core that allows hardware multi-threading; the cores
    are connected via a NoC.  The paper is a good example of by-design 
    security against micro-architectural attacks, in the sense
    1) although implying a performance impact, the NoC is deterministic st.
       ``no traffic sent by any other host can ever impact the ability of another to communicate and thus there are no timing/resource exhaustion side channels'',
    2) the L1 cache is essentially partitioned on a thread basis: each of
       the threads accesses a region of the cache whose separation is
       enforced in hardware.
  }
}

@techreport{MASCAB:LiuMcG:09,
  keywords     = KEYWORDS,
  author       = {I. Liu and D. McGrogan},
  title        = {Elimination of Side Channel attacks on a Precision Timed Architecture},
  institution  = {Electrical Engineering and Computer Sciences, U.C. Berkley},
  number       = {EECS-2009-15},
  year         = {2009},
  addendum     = {
    This paper analyses the PRecision Timed Architecture (PRET) as a means
    of preventing side-channel attack; the PRET processor core is designed 
    for real-time systems, and aims at {\em predictable} performance.  It
    a) uses hardware-supported SMT, with per-thread scratch-pad memories
       ensuring inter-thread isolation (e.g., wrt. cache behaviour),
       and, perhaps more importantly,
    b) includes a notion of programmer-specified deadlines: an instruction
       can be annotated with a deadline (e.g., ``this must always take $x$ 
       cycles''), which is enforced by the core during execution.
    Although the latter implies a {\em stall} for some number of cycles to
    meet the deadline (which may be observable via power analysis), it can
    be harnessed as a way to produce constant-time execution; all details 
    aside, one could view this as a form of transparency and predictability
    wrt. execution time (stemming from the real-time use-case) not evident 
    in many other cores and/or ISAs.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/misc,topic=pos/software}}

@article{MASCAB:BraJanBon:15,
  keywords     = KEYWORDS,
  author       = {B.A. Braun and S. Jana and D. Boneh},
  title        = {Robust and Efficient Elimination of Cache and Timing Side Channels},
  journal      = {CoRR},
  volume       = {abs/1506.00189},
  year         = {2015},
  url          = {http://arxiv.org/abs/1506.00189},
  addendum     = {
    The use of constant-time implementation techniques is a generic approach
    to mitigation of time-driven side-channel attacks (which include selected 
    cache-based attacks as a subset); irrespective of security-critical used,
    this hiding countermeasure forces the execution time of a target to be 
    constant and thus prevents leakage of the former via observation of the
    latter.  Realisation of this approach can be difficult; solutions can be 
    platform-specific and fragile wrt. compilation and assembly steps, or 
    minor variations in micro-architecture.

    This paper takes a different approach, applying the countermeasure at a
    higher level: at a fine-grained level, guided by programmer annotation
    of source code, the {\em kernel} will automatically
    1) intelligently pad the execution time of processes to prevent leakage; 
       this needs some care, but essentially forces the worst-case execution 
       time for each process,
    2) enforce isolation wrt. shared micro-architectural resources, e.g.,
       using cache flushing and a form of page colouring.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=channel/side/misc,topic=pos/analysis}}

@unpublished{MASCAB:IraEisSun:16,
  keywords     = KEYWORDS,
  author       = {G. Irazoqui and T. Eisenbarth and B. Sunar},
  title        = {{MASScan}: Stopping Microarchitectural Attacks Before Execution},
  howpublished = {Cryptology ePrint Archive, Report 2016/1196},
  year         = {2016},
  url          = {http://eprint.iacr.org/2016/1196},
  addendum     = {
    As outlined in Section $1$, countermeasures against micro-architectural
    attack tend to be either 
    preventive (i.e., prevent an attack by-design)
    or
    reactive   (i.e., monitor execution, then react to prevent an attack).
    This paper takes a slightly different approach by presenting a program
    analysis tool called {\sc MASScan}: it applies static analysis to each
    program provided as input, attempting to classify it as malicious iff.
    it satisfies metrics associated with such attacks (e.g., matches what
    is known wrt. attack programs).  The metrics are instruction-focused
    on the whole; for example known x86 cache attack programs (e.g., per
    those in~\cite{MASCAB:Yarom}) utilise {\tt rdtsc} for high-resolution
    timing, so this otherwise abnormal instruction can be used as evidence
    that a given program is malicious.

    The paper pitches {\sc MASScan} as a means of vetting programs within
    an app store setting.  Using a baseline corpus of $24$ attack programs,
    the false-positive and -negative rates demonstrate the approach is
    effective up to a point: it miss-classifies $6\%$ of benign programs 
    (e.g., ffmpeg), with the reasons explained in Table $3$.
  }
}

% =============================================================================
@STRING{KEYWORDS={class=crosscut/perfctr,topic=neg}}

@inproceedings{MASCAB:BhaMuk:15,
  keywords     = KEYWORDS,
  author       = {S. Bhattacharya and D. Mukhopadhyay},
  title        = {Who Watches the Watchmen?: Utilizing Performance Monitors for Compromising Keys of {RSA} on {Intel} Platforms},
  booktitle    = {Cryptographic Hardware and Embedded Systems (CHES)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9293},
  pages        = {248--266},
  year         = {2015},
  addendum     = {
    At a high level, this paper is arguably best described by relating it
    to two other papers:
    1) it is similar to~\cite{MASCAB:UhsGeoVer:08}
       in that it uses a similar underlying form of leakage: the attacker
       is assumed to have access to the hardware performance counters, and
       uses this ability to monitor the branch predictor unit (and thereby
       branch behaviour of the target process),
    2) it is similar to~\cite{MASCAB:DKLMQW:98}
       in that the attack strategy (i.e., Algorithm $4$) is more or less
       the same as a standard RSA timing attack, and targets conditional
       subtraction (and hence conditional branch) executed by Montgomery 
       multiplication: the clear difference is that it uses a simulated 
       branch predictor to model behaviour, and concrete branch predictor
       behaviour (collected via performance counters) as a distinguisher.
    The attack is applied to vanilla RSA, and the PKCS\#1-based RSA-OAEP
    design.
  }
}

@inproceedings{MASCAB:BhaRebMuk:13,
  keywords     = KEYWORDS,
  author       = {S. Bhattacharya and C. Rebeiro and D. Mukhopadhyay},
  title        = {Unraveling {Timewarp}: What All the Fuzz is About?},
  booktitle    = {Hardware and Architectural Support for Security and Privacy (HASP)},
  pages        = {8:1--8:8},
  year         = {2013},
  addendum     = {
    This paper demonstrates that {\sc TimeWarp}~\cite{MASCAB:MarDemSet:12}
    does not prevent attacks succeeding; specifically, if the epoch time
    $e$ is less than the time $t$ associated with some operation or event 
    of interest (e.g., a cache-miss for a particular memory access), then
    it is possible to eliminate the impact of {\sc TimeWarp} by repeating
    the operation.  Section $5$ evaluates this approach in two settings
    (namely an artificial, access-driven setting, and a real, time-driven
    attack on CLEFIA), concluding {\sc TimeWarp} reduces the probability
    of success (resp. increases the measurements required), but does not
    {\em prevent} success.
  }
} 

@inproceedings{MASCAB:UhsGeoVer:08,
  keywords     = KEYWORDS,
  author       = {L. Uhsadel and A. Georges and I. Verbauwhede},
  title        = {Exploiting Hardware Performance Counters},
  booktitle    = {Fault Diagnosis and Tolerance in Cryptography (FTDC)},
  pages        = {59--67},
  year         = {2008},
  addendum     = {
    This paper offers more concrete results that stem from a comment by
    Tiri~\cite[Section 2.3]{MASCAB:Tiri:07}, namely that
    ``{\em  performance counters paint a more accurate picture and -- if for a moment we ignore the fact that they can only be accessed using privileged ring-0 instructions--, they could enable better and faster attacks than the timestamp counter}''.
    That is, it explores the idea of using performance counters in order
    to facilitate micro-architectural attack; intuitively, this approach 
    should enable an {\em extremely} strong attacker due to the range and
    fidelity of accessible information.

    The approach is validated using an attack~\cite{MASCAB:BonMir:06} on
    AES as implemented in OpenSSL.  While effective, there are a range of
    caveats in practice:
    In practice, however, there are a number of caveats:
    a) access to performance counters is often privileged, meaning that a
       user mode attacker cannot do so without assistance from the kernel
       (e.g., via a driver),
    b) the attacker needs to select a performance counting mode that, as
       much as possible, associates events specifically with the target 
       process; the normal mode has a process count events wrt. itself,
       and any modes that count events for {\em all} processes and the
       kernel, for example, naturally introduce a lot of noise wrt. the
       event(s) of interest,
       and
    c) performance counters are not typically designed to support precise
       counting; there is some noise inherent in the results they yield,
       st. precisely distinguishing fine-grained events (e.g., say $n$ vs.
       $n+1$ cache misses) is harder than might be expected.
    In addition, the attack replaces the access-based L2 cache eviction 
    with use of the (privileged) {\tt wbinvd} instruction: this requires
    support from an additional kernel driver, so could be deemed invasive
    vs. alternatives.
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=crosscut/perfctr,topic=pos}}

@inproceedings{MASCAB:MarDemSet:12,
  keywords     = KEYWORDS,
  author       = {R. Martin and J. Demme and S. Sethumadhavan},
  title        = {{TimeWarp}: Rethinking Timekeeping and Performance Monitoring Mechanisms to Mitigate Side-channel Attacks},
  booktitle    = {International Symposium on Computer Architecture (ISCA)},
  pages        = {118--129},
  year         = {2012},
  addendum     = {
    This paper introduces {\sc TimeWarp}, a mechanism for controlling access
    to the high-precision timer required by most micro-architectural attacks.
    Although it does not cite~\cite{MASCAB:Hu:91}, much of the analysis and
    design is similar: it first identifies three classes of timer, namely
    1) hardware-based internal sources (e.g., {\tt rdtsc}),
    2) hardware-based external sources (e.g., interrupts stemming from network activity),
       and
    3) software-only examples that allow synthesis of a timer,
    and then,
    a) provide an patch to (e.g., in the microcode for) {\tt rdtsc} so it
       yields randomised behaviour when in a secure mode,
    b) reason that external sources cannot be delivered fast enough to offer
       a high enough resolution timer,
       and
    c) demonstrate that synthesised timers that use multiply threads (e.g.,
       one to produce periodic events, one to consume them) can be detected
       by using the existing concept of a hardware race detector.

    The idea in point a) is to divide time into epochs, whose length varies 
    randomly between $2^{e-1}$ and $2^e-1$ cycles (for a configurable $e$, 
    supplied by the {\tt twrdtsc} instruction); execution of {\tt rdtsc} is 
    deferred until the next epoch boundary then subject to a second random
    delay of between $0$ and $E-1$ cycles.  The timer value then has a third
    randomisation factor of between $0$ and $E-1$ cycles added to it.  There
    is an emphasis throughout(e.g., Section $4$) on the issue of (backward) 
    compatibility: the patched timer must allow as many existing applications 
    to work as possible, while still affording an improvement in security.
  }
}

@inproceedings{MASCAB:VatDasSha:11,
  keywords     = KEYWORDS,
  author       = {B.C. Vattikonda and S. Das and H. Shacham},
  title        = {Eliminating Fine Grained Timers in {Xen}},
  booktitle    = {ACM Cloud Computing Security Workshop (CCSW)},
  pages        = {41--46},
  year         = {2011},
  addendum     = {
    The fuzzy time concept was conceived and realised in~\cite{MASCAB:Hu:91}.
    However, this paper notes that it remains unclear how the concept applies
    in a modern context; in particular, the x86 {\tt rdtsc} instruction means
    an attack process can access a high-precision, cycle accurate timer from
    user space alone (i.e., without doing so via the kernel).  Focusing on 
    kernels executing under the Xen hypervisor, the paper describes and then
    analyses the impact of 
    a) virtualising the {\tt rdtsc} instruction using a Xen trap-and-emulate
       mechanism already present,
       then
    b) adjusting the timer value before return to the virtual machine, hence
       implementing a version of fuzzy time.
    The bulk of the paper considers masking the timer value LSBs, applying a
    step function and thereby reducing the resolution.  The impact of doing 
    so is limited wrt. performance, but there are limits wrt. correctness: it
    seems too little resolution impacts, for example, the network sub-system
    (e.g., the TCP stack uses {\tt rdtsc} to measure RTT).  Section $5.1$ has
    a second option, which adds a random perturbation to the timer value while
    maintaining the monotonically increasing property.
  }
} 

@inproceedings{MASCAB:Hu:91,
  keywords     = KEYWORDS,
  author       = {W.M. Hu},
  title        = {Reducing timing channels with fuzzy time},
  booktitle    = {IEEE Symposium on Security \& Privacy (S\&P)}, 
  pages        = {8--20}, 
  year         = {1991},
  addendum     = {
    This paper discusses a concept it terms {\em fuzzy} time, which could be
    read as {\em randomised} time.  Implemented as part of the VAX security 
    kernel, fuzzy time aims to prevent covert timing channels by disallowing 
    access to a precise timer; randomising the timer essentially adds noise,
    and so degrades the quality of measurements and hence channel bandwidth.
    The paper first surveys the timers available to an attacker: these could
    be classified as
    1) real        (Section $4.1$ outlines a VAX system-supplied clock, that
       drives a timer interrupt and is accessible at a memory mapped address),
       or
    2) synthesised (Section $4.2.2$, for example, discusses how a timer could
       be derived from I/O activity).
    It then outlines how both classes can be randomised in Sections $5.1$ and
    $5.2$: the idea is to 
    a) randomise the timer interrupt (initialising the interrupt controller 
       with a random starting point) and reduce the resolution (to $1/10$ of
       a second),
       and
    b) embellish the I/O sub-system with features that introduce a random 
       delay between request and acknowledge (or notification) events.
    Evaluation of the implementation shows only minor degradation wrt. the
    system performance, while reducing covert timing channel bandwidth by
    up to two orders of magnitude (to below $10$ bits per second).
  }
}

@inproceedings{MASCAB:PopKli:74,
  keywords  = KEYWORDS,
  author    = {G.J. Popek and C.S. Kline},
  title     = {Verifiable Secure Operating System Software},
  booktitle = {National Computer Conference and Exposition},
  pages     = {145--151},
  year      = {1974},
  addendum  = {
    This paper makes a case for delivering robust, verifiable guarantees of
    security (especially protection) in operating system kernels; it offers
    an overview of how a particular kernel at UCLA is designed specifically
    to do so.  In a sense, it is amazing that such arguments were made and
    yet (bar notable exceptions such as seL4~\cite{MASCAB:KEHACDEEKNSTW:09})
    the same challenges still exist now.

    Among the discussion of motivation and design rationale, the confinement
    problem~\cite{MASCAB:Lampson:73} is cited as a challenge.  It suggests a
    countermeasure to prevent (or block) such communication channels (e.g., 
    covert channels): the idea is to disallow access to ``real time'' via a
    (high enough resolution) timer, only allowing access to a {\em virtual}
    timer from each virtual machine (a concept synonymous with process in 
    the kernel discussed).  Of course this only addresses timing channels,
    but, put another way, it means an attack process can only time activity
    relating to {\em itself} rather than some other, target process.
  }
} 

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=crosscut/interrupt}}

@unpublished{MASCAB:TakNogMor:11,
  keywords     = KEYWORDS,
  author       = {T. Takehisa and H. Nogawa and M. Morii},
  title        = {{AES} Flow Interception: Key Snooping Method on Virtual Machine - Exception Handling Attack for {AES-NI}},
  howpublished = {Cryptology ePrint Archive, Report 2011/428},
  year         = {2011},
  url          = {http://eprint.iacr.org/2011/428},
  addendum     = {
    This paper presents an attack whereby a malicious hypervisor, or VMM,
    is able to read the AES keys of a target kernel, or VM.  The idea is:
    1) the VMM executes on a platform without AES-NI, and virtualises the
       {\tt cpuid} instruction st. it reports AES-NI {\em is} available,
    2) when the VM mistakenly executes an AES-NI instruction, this causes
       an (unknown instruction) exception; the VMM intercepts this, and
       thus reads the AES cipher key resident in some register.
    In a sense it is obvious this is possible, because the VMM controls
    resources allocated to the VM; the challenge addressed is more one of
    how the VM can be made aware an AES operation is being carried out by
    the VM (i.e., the challenge is basically one of synchronisation).
  }
}

% -----------------------------------------------------------------------------
@STRING{KEYWORDS={class=crosscut/ids}}

@inproceedings{MASCAB:Payer:16,
  keywords     = KEYWORDS,
  author       = {M. Payer},
  title        = {{HexPADS}: A Platform to Detect ``Stealth'' Attacks},
  booktitle    = {Engineering Secure Software and Systems (ESSoS)},
  publisher    = {Springer-Verlag},
  series       = {LNCS 9639},
  pages        = {138--154},
  year         = {2016},
  addendum     = {
    This paper describes {\sc HexPADS}, a system-level countermeasure against
    micro-architectural attacks: as with~\cite{MASCAB:ChiSavYil:16}, the idea
    is to monitor execution of processes and classify them as malign (or not)
    based on their behaviour (i.e., it is an IDS of sorts).  {\sc HexPADS} is
    pitched as a user-space daemon process, although it seems reasonable that
    it {\em could} be integrated into a kernel (which reduces some overheads,
    and potentially offers easier access to some data).

    Given their remit is similar, a contrast with~\cite{MASCAB:ChiSavYil:16} 
    seems a sensible way to describe the content.  Positive aspects include
    the fact that
    1) the system gathers and bases decisions on a {\em range} of data about
       execution of a given process, including hardware performance counters
       and the Linux {\tt proc} file system,
    2) this diversity allows it to addresses a {\em range} of attack types, 
       including both cache-based side-channel attacks and Rowhammer attacks.
    On the other hand,
    1) the detection mechanism is based on a rule set per attack type, which
       is arguably more rigid than say a machine learning based alternative,
    2) the description and evaluation is somewhat informal, so
       a) it is unclear how parameters for the rule sets were derived,
       b) some aspects of the evaluation (e.g., false-positive rate, or time
          to detection, which is important in that it determines whether an
          attack can be prevented from completing) are unclear.
  }
}

@article{MASCAB:ChiSavYil:16,
  keywords     = KEYWORDS,
  author       = {M. Chiappetta and E. Sava\c{s} and C. Yilmaz},
  title        = {Real time detection of cache-based side-channel attacks using hardware performance counters},
  journal      = {Applied Soft Computing},
  volume       = {49},
  pages        = {1162--1174},
  year         = {2016},
  addendum     = {
    This paper presents a countermeasure against micro-architectural attacks:
    the idea is for the kernel to dynamically monitor a process (e.g., using
    hardware performance counters), and decide whether or not the behaviour 
    it exhibits suggests it is an attack process.  Put another way, the idea
    is similar to an IDS in the sense the kernel detects and then deals with
    (e.g., terminates) an attack process at run-time; ideally the detection
    can be efficient enough to prevent an attack succeeding.

    Three different techniques for classifying processes as an attacker (or
    not), namely
    1) statistical correlation,
    2) anomaly detection,
    3) supervised learning (using a neural network),
    with the latter two best described as instances of machine learning.  An
    evaluation based on a {\sc Flush+Reload}-based attack process highlights
    a trade-off between detection accuracy and latency, but also negligible
    overhead of applying each technique; either way, it is clear this attack  
    (or at least this attack process) can be detected soon enough to prevent
    it succeeding.
  }
}

@article{MASCAB:WDWMKW:14,
  keywords     = KEYWORDS,
  author       = {J. Wu and L. Ding and Y. Wu and N. Min-Allah and S.U. Khan and Y. Wang},
  title        = {C\({}^{\mbox{2}}\)Detector: a covert channel detection framework in cloud computing},
  journal      = {Security and Communication Networks},
  volume       = {7},
  number       = {3},
  pages        = {544--557},
  year         = {2014},
  addendum     = {
    This paper presents a mechanism to detect exploitation of covert channels
    at run-time; there are two components, namely
    1) a (single)             hypervisor             resident {\em   captor},
       which hooks and monitors hypercalls, passing record-based information 
       to
    2) a (per virtual machine supervisor (or kernel) resident {\em detector},
       which analyses the records and then classifies associated activity as
       either a covert channel or not; Markov- and Bayesian-based models are
       used as classifiers.  
    The mechanism can detect various covert channels, including (per Section
    $4.3.2$) those based on use of the (shared) cache.
  }
}

@article{MASCAB:AlaSet:15,
  keywords     = KEYWORDS,
  author       = {M. Alam and S. Sethi},
  title        = {Detection of information leakage in cloud},
  journal      = {CoRR},
  volume       = {abs/1504.03539},
  year         = {2015},
  url          = {http://arxiv.org/abs/1504.03539}
}

% =============================================================================
